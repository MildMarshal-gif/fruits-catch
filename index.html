<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>フルーツキャッチ</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@700;800;900&family=Zen+Maru+Gothic:wght@700;900&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg1:#7bdff2; /* sky */
      --bg2:#b2f7ef; /* mint */
      --bg3:#eff7f6; /* cloud */
      --accent:#ff70a6;
      --accent2:#ff9770;
      --accent3:#ffd670;
      --good:#46d19f;
      --bad:#ff4d6d;
      --ink:#1f2937;
      --card:#ffffffcc;
      --fever1:#ffd670;
      --fever2:#9b5de5;
      --fever3:#ff70a6;
      --ui-scale:1;
      --hud-scale:1;
      --title-scale:1;
      --fx-density:1;
      --fruit-scale:1;
      --basket-scale:1;
      --pause-scale:1;
      --motion-scale:1;
      --tap-target:40px;
      --hud-inset-top:14px;
      --hud-inset-side:14px;
      --text-leading:1.35;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; }
    body{
      font-family: "M PLUS Rounded 1c","Zen Maru Gothic","Kosugi Maru","Hiragino Maru Gothic ProN",
                   "Yu Gothic UI","Meiryo",system-ui,sans-serif;
      display:grid;
      place-items:center;
      overflow:hidden;
      background:
        radial-gradient(1200px 700px at 20% 10%, var(--bg3) 0 25%, transparent 26%),
        radial-gradient(900px 600px at 80% 20%, var(--bg3) 0 22%, transparent 23%),
        radial-gradient(800px 500px at 50% 0%, #ffffffaa 0 18%, transparent 19%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
    }

    .wrap{
      width:min(980px, 96vw);
      aspect-ratio: 16 / 9;
      position:relative;
      border-radius:24px;
      box-shadow: 0 18px 55px rgba(0,0,0,.18);
      overflow:hidden;
      background: linear-gradient(180deg, rgba(255,255,255,.20), rgba(255,255,255,.05));
      backdrop-filter: blur(8px);
    }

    canvas{ width:100%; height:100%; display:block; }

    .hud{
      position:absolute;
      inset:
        calc(var(--hud-inset-top) + env(safe-area-inset-top))
        var(--hud-inset-side)
        auto
        var(--hud-inset-side);
      display:grid;
      grid-template-columns:minmax(0, 1fr) auto;
      column-gap: calc(12px * var(--hud-scale));
      row-gap: calc(8px * var(--hud-scale));
      align-items:start;
      pointer-events:none;
    }

    .pill{
      background: var(--card);
      color:var(--ink);
      border: 2px solid rgba(255,255,255,.65);
      border-radius:999px;
      padding: calc(10px * var(--hud-scale)) calc(14px * var(--hud-scale));
      display:flex;
      gap: calc(12px * var(--hud-scale));
      align-items:center;
      flex-wrap:wrap;
      min-width:0;
      max-width:100%;
      font-weight:900;
      font-size: calc(14px * var(--hud-scale));
      line-height:1.2;
      letter-spacing:.2px;
      box-shadow: 0 10px 22px rgba(0,0,0,.12);
      pointer-events:none;
    }

    .pill .big{ font-size: calc(18px * var(--hud-scale)); }
    .mini{ font-size: calc(14px * var(--hud-scale)); opacity:.85; font-weight:900; }

    .hearts{ display:flex; gap:6px; align-items:center; }
    .heart{
      width: calc(18px * var(--hud-scale));
      height: calc(18px * var(--hud-scale));
      filter: drop-shadow(0 2px 2px rgba(0,0,0,.15));
    }

    .btns{
      display:flex;
      gap: calc(10px * var(--hud-scale));
      flex-wrap:wrap;
      justify-content:flex-end;
      pointer-events:auto;
    }
    button{
      cursor:pointer;
      border:none;
      border-radius:999px;
      min-height: var(--tap-target);
      min-width: var(--tap-target);
      padding: calc(10px * var(--hud-scale)) calc(14px * var(--hud-scale));
      font-weight:900;
      font-size: calc(14px * var(--ui-scale));
      line-height:1.15;
      color:#102a43;
      background:#ffffff;
      box-shadow: 0 10px 22px rgba(0,0,0,.12);
      border:2px solid rgba(255,255,255,.65);
      transition: transform .08s ease, box-shadow .15s ease;
      font-family: inherit;
      touch-action: manipulation;
    }
    button:hover{ transform: translateY(-1px); box-shadow: 0 14px 28px rgba(0,0,0,.16); }
    button:active{ transform: translateY(1px); }
    button:focus-visible{
      outline: 3px solid rgba(16,42,67,.7);
      outline-offset: 2px;
    }

    .badge{
      position:absolute;
      right: var(--hud-inset-side);
      top: calc(var(--hud-inset-top) + env(safe-area-inset-top) + (58px * var(--hud-scale)));
      background: rgba(255,255,255,.92);
      border:2px solid rgba(255,255,255,.75);
      box-shadow: 0 10px 22px rgba(0,0,0,.12);
      border-radius: 16px;
      padding: calc(10px * var(--hud-scale)) calc(12px * var(--hud-scale));
      font-weight:1000;
      font-size: calc(14px * var(--hud-scale));
      line-height:1.2;
      color:var(--ink);
      display:none;
      max-width:min(74vw, 360px);
      pointer-events:none;
    }
    .badge.show{ display:block; }
    .badge .line{ display:flex; align-items:center; gap:10px; }
    .badge .spark{
      font-size: calc(18px * var(--hud-scale));
      filter: drop-shadow(0 2px 2px rgba(0,0,0,.12));
    }

    .overlay{
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      background: linear-gradient(180deg, rgba(0,0,0,.10), rgba(0,0,0,.22));
      backdrop-filter: blur(6px);
      opacity:0;
      pointer-events:none;
      transition: opacity .25s ease;
    }
    .overlay.show{ opacity:1; pointer-events:auto; }

    .card{
      width:min(540px, 92%);
      border-radius:26px;
      padding:
        calc(22px * var(--ui-scale))
        calc(22px * var(--ui-scale))
        calc(18px * var(--ui-scale));
      background: rgba(255,255,255,.92);
      box-shadow: 0 18px 55px rgba(0,0,0,.2);
      border: 2px solid rgba(255,255,255,.75);
      text-align:center;
      color:var(--ink);
      line-height: var(--text-leading);
    }
    .title{
      font-size: calc(34px * var(--title-scale));
      line-height:1.15;
      font-weight:1000;
      margin:0 0 calc(10px * var(--ui-scale));
      letter-spacing:.3px;
    }
    .subtitle{
      margin:0 0 calc(14px * var(--ui-scale));
      font-size: calc(16px * var(--ui-scale));
      line-height:1.4;
      font-weight:900;
      opacity:.92;
    }
    .how{
      margin:0 0 calc(18px * var(--ui-scale));
      padding: calc(14px * var(--ui-scale)) calc(16px * var(--ui-scale));
      border-radius:18px;
      background: linear-gradient(90deg, rgba(255,112,166,.18), rgba(255,214,112,.22), rgba(70,209,159,.18));
      border: 2px dashed rgba(31,41,55,.18);
      font-size: calc(15px * var(--ui-scale));
      font-weight:900;
      line-height:1.45;
    }
    .stack{
      display:flex;
      gap: calc(10px * var(--ui-scale));
      justify-content:center;
      flex-wrap:wrap;
      margin-top: calc(6px * var(--ui-scale));
    }
    .note{
      font-size: calc(12px * var(--ui-scale));
      opacity:.75;
      font-weight:900;
      margin-top: calc(10px * var(--ui-scale));
      line-height:1.4;
    }

    :root[data-device="mobile"] .hud{
      grid-template-columns:1fr;
    }

    :root[data-device="mobile"] .pill{
      width:100%;
    }

    :root[data-device="mobile"] .btns{
      width:100%;
      justify-content:space-between;
    }

    /* Responsive tweaks */
    @media (max-width: 680px) {
      body{
        place-items: stretch;
      }

      .wrap{
        width: 100vw;
        height: 100dvh;        /* iPhone address bar safe */
        aspect-ratio: auto;
        border-radius: 0;
      }

      canvas{
        width: 100%;
        height: 100%;
      }

      .card{
        width: min(560px, 94vw);
        max-height: calc(100dvh - 28px - env(safe-area-inset-top) - env(safe-area-inset-bottom));
        overflow: auto;
        -webkit-overflow-scrolling: touch;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      .overlay,
      button{
        transition:none;
      }
    }
  </style>
</head>

<body>
  <div class="wrap" aria-label="フルーツキャッチゲーム">
    <canvas id="game" width="1280" height="720"></canvas>

    <div class="hud">
      <div class="pill">
        <span class="big">スコア:</span>
        <span id="score" class="big">0</span>
        <span style="opacity:.55;">|</span>
        <span class="big">ミス:</span>
        <span class="hearts" id="hearts"></span>
        <span style="opacity:.55;">|</span>
        <span class="mini">スピード:</span>
        <span id="speedMul" class="mini">x1.00</span>
      </div>

      <div class="btns">
        <button id="restartBtn" type="button">リスタート</button>
        <button id="pauseBtn" type="button">一時停止</button>
      </div>
    </div>

    <div class="badge" id="feverBadge" aria-live="polite">
      <div class="line">
        <span class="spark">✨</span>
        <span>フィーバー</span>
        <span id="feverTime" style="font-weight:1000;">20.0s</span>
        <span style="opacity:.7;">残り</span>
      </div>
    </div>

    <div class="overlay show" id="overlay">
      <div class="card">
        <h1 class="title">🍓 フルーツキャッチ</h1>
        <p class="subtitle">カゴを動かして、フルーツをキャッチしよう！</p>
        <div class="how">
          ← / → か A / D で移動<br/>
          マウスやタッチでも移動OK<br/>
          3回ミスでゲームオーバー<br/>
          ⭐を取るとフィーバー（得点2倍）
        </div>
        <div class="stack">
          <button id="startBtn" type="button"
            style="background:linear-gradient(90deg,var(--accent),var(--accent3)); color:#1f2937;">
            スタート！
          </button>
          <button id="soundBtn" type="button">サウンド: オン</button>
        </div>
        <div class="note">スペースキーでも一時停止できます</div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      // UI
      const scoreEl = document.getElementById('score');
      const heartsEl = document.getElementById('hearts');
      const overlay = document.getElementById('overlay');
      const startBtn = document.getElementById('startBtn');
      const restartBtn = document.getElementById('restartBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const soundBtn = document.getElementById('soundBtn');
      const speedMulEl = document.getElementById('speedMul');
      const feverBadge = document.getElementById('feverBadge');
      const feverTimeEl = document.getElementById('feverTime');
      const root = document.documentElement;
      const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
      const coarsePointerQuery = window.matchMedia('(pointer:coarse)');

      const DEVICE_PRESETS = {
        mobile: {
          uiScale: 0.86,
          hudScale: 0.83,
          titleScale: 0.84,
          fxDensity: 0.56,
          fruitScale: 0.90,
          basketScale: 0.92,
          pauseScale: 0.78,
          tapTarget: 44
        },
        tablet: {
          uiScale: 0.95,
          hudScale: 0.91,
          titleScale: 0.93,
          fxDensity: 0.78,
          fruitScale: 0.95,
          basketScale: 0.96,
          pauseScale: 0.90,
          tapTarget: 42
        },
        desktop: {
          uiScale: 1.0,
          hudScale: 1.0,
          titleScale: 1.0,
          fxDensity: 1.0,
          fruitScale: 1.0,
          basketScale: 1.0,
          pauseScale: 1.0,
          tapTarget: 40
        }
      };

      const BASE_BASKET_W = 240;
      const BASE_BASKET_H = 62;
      const BASE_FRUIT_RADIUS_MIN = 28;
      const BASE_FRUIT_RADIUS_MAX = 42;
      let fruitRadiusMin = BASE_FRUIT_RADIUS_MIN;
      let fruitRadiusMax = BASE_FRUIT_RADIUS_MAX;
      let fxDensity = 1;
      let particleDensity = 1;
      let backgroundMotionScale = 1;
      let rotationMotionScale = 1;
      let pausePanelScale = 1;
      let floatTextScale = 1;

      // Game constants
      const MAX_MISSES = 3;

      // Basket (kid-friendly big)
      const basket = {
        w: BASE_BASKET_W,
        h: BASE_BASKET_H,
        x: 1280 / 2,
        y: 720 - 90,
        vx: 0,
        speed: 1150, // px/s
        targetX: null
      };

      // Fruits with fixed speed multipliers (0.8-1.3) and points
      const FRUITS = [
        { emoji:'🍌', mul:0.80, points: 8,  color:'#ffd670' },
        { emoji:'🍏', mul:0.88, points: 9,  color:'#7ae582' },
        { emoji:'🍎', mul:0.95, points:10,  color:'#ff4d6d' },
        { emoji:'🍑', mul:1.02, points:10,  color:'#ff9770' },
        { emoji:'🍓', mul:1.10, points:11,  color:'#ff70a6' },
        { emoji:'🍇', mul:1.20, points:12,  color:'#9b5de5' },
        { emoji:'🍉', mul:1.30, points:13,  color:'#46d19f' },
      ];

      // Special star
      const STAR = { emoji:'⭐', chance:0.01 };

      // Spawn rate & base fall speed (global progression will multiply)
      function spawnInterval() {
        // start ~0.85s -> later ~0.55s
        const t = Math.min(1, totalElapsed / 120);
        return 0.85 - t * 0.30;
      }
      function baseFallSpeed() {
        return 310; // base speed before multipliers
      }

      // State
      let running = false;
      let paused = false;
      let gameOver = false;
      let score = 0;
      let misses = 0;

      // elapsed time for progression
      let totalElapsed = 0; // seconds

      // Fever
      let fever = false;
      let feverEnd = 0; // seconds (game time)
      const FEVER_DURATION = 20;

      // Entities
      const objects = []; // fruits & star
      const pops = [];
      const floatTexts = [];

      // Input
      const keys = new Set();
      window.addEventListener('keydown', (e) => {
        if (['ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
        keys.add(e.key);
        if (e.key === ' ' && running && !gameOver) togglePause();
      });
      window.addEventListener('keyup', (e) => keys.delete(e.key));

      function setBasketByClientX(clientX) {
        const rect = canvas.getBoundingClientRect();
        const x = (clientX - rect.left) / rect.width * canvas.width;
        basket.targetX = clamp(x, basket.w/2 + 14, canvas.width - basket.w/2 - 14);
      }
      canvas.addEventListener('mousemove', (e) => setBasketByClientX(e.clientX));
      canvas.addEventListener('touchstart', (e) => {
        if (e.touches?.[0]) setBasketByClientX(e.touches[0].clientX);
      }, {passive:true});
      canvas.addEventListener('touchmove', (e) => {
        if (e.touches?.[0]) setBasketByClientX(e.touches[0].clientX);
      }, {passive:true});

      // Buttons
      startBtn.addEventListener('click', () => startGame());
      restartBtn.addEventListener('click', () => restartGame());
      pauseBtn.addEventListener('click', () => togglePause());

      // Audio (WebAudio synth BGM: normal & fever)
      const audioCtx = (() => {
        try { return new (window.AudioContext || window.webkitAudioContext)(); }
        catch { return null; }
      })();
      let soundOn = true;

      soundBtn.textContent = `サウンド: ${soundOn ? 'オン' : 'オフ'}`;

      soundBtn.addEventListener('click', async () => {
        soundOn = !soundOn;
        soundBtn.textContent = `サウンド: ${soundOn ? 'オン' : 'オフ'}`;
        if (audioCtx && soundOn) {
          try { await audioCtx.resume(); } catch {}
        }
        setMusicEnabled(soundOn);
      });

      // SFX
      function sfx(type='catch') {
        if (!audioCtx || !soundOn) return;
        const t0 = audioCtx.currentTime;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.connect(g); g.connect(audioCtx.destination);

        let f1=700, f2=1000, dur=0.12;
        if (type==='miss'){ f1=240; f2=140; dur=0.14; }
        if (type==='star'){ f1=880; f2=1760; dur=0.18; }

        o.type = 'sine';
        o.frequency.setValueAtTime(f1, t0);
        o.frequency.exponentialRampToValueAtTime(f2, t0 + dur*0.6);

        g.gain.setValueAtTime(0.0001, t0);
        g.gain.exponentialRampToValueAtTime(0.20, t0 + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

        o.start(t0);
        o.stop(t0 + dur + 0.02);
      }

      // BGM sequencer
      const music = (() => {
        if (!audioCtx) return null;

        const master = audioCtx.createGain();
        master.gain.value = 0.22;
        master.connect(audioCtx.destination);

        const normalGain = audioCtx.createGain();
        const feverGain  = audioCtx.createGain();
        normalGain.gain.value = 0.0;
        feverGain.gain.value  = 0.0;
        normalGain.connect(master);
        feverGain.connect(master);

        let enabled = true;
        let mode = 'normal'; // 'normal' | 'fever'

        const lookAhead = 0.12;
        const interval = 25; // ms
        let timer = null;
        let nextNoteTime = 0;

        // cute chord-ish notes (freq)
        const N = {
          C4:261.63, D4:293.66, E4:329.63, F4:349.23, G4:392.00, A4:440.00, B4:493.88,
          C5:523.25, D5:587.33, E5:659.25, G5:783.99, A5:880.00
        };

        // Step patterns (16 steps)
        const normalMelody = [N.E5,0,N.G5,0, N.A5,0,N.G5,0, N.E5,0,N.D5,0, N.C5,0,N.D5,0];
        const normalBass   = [N.C4,0,N.C4,0, N.A4,0,N.A4,0, N.F4,0,N.F4,0, N.G4,0,N.G4,0];

        const feverMelody  = [N.A5,N.G5,N.E5,0, N.G5,N.E5,N.D5,0, N.E5,N.G5,N.A5,0, N.G5,N.E5,N.D5,0];
        const feverBass    = [N.A4,0,N.A4,0, N.G4,0,N.G4,0, N.E4,0,N.E4,0, N.D4,0,N.D4,0];

        const bpmNormal = 118;
        const bpmFever  = 140;

        function playNote(time, freq, duration, gainNode, type='triangle') {
          if (!freq) return;
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.type = type;
          o.frequency.setValueAtTime(freq, time);

          g.gain.setValueAtTime(0.0001, time);
          g.gain.exponentialRampToValueAtTime(0.18, time + 0.01);
          g.gain.exponentialRampToValueAtTime(0.0001, time + duration);

          o.connect(g);
          g.connect(gainNode);
          o.start(time);
          o.stop(time + duration + 0.01);
        }

        let step = 0;

        function scheduler() {
          if (!enabled) return;

          const now = audioCtx.currentTime;
          while (nextNoteTime < now + lookAhead) {
            const isFever = (mode === 'fever');
            const bpm = isFever ? bpmFever : bpmNormal;
            const secPerBeat = 60 / bpm;
            const stepDur = secPerBeat / 4; // 16th note

            const mel = isFever ? feverMelody : normalMelody;
            const bas = isFever ? feverBass   : normalBass;

            // melody
            playNote(nextNoteTime, mel[step % 16], stepDur*0.92, isFever ? feverGain : normalGain, 'triangle');
            // bass
            playNote(nextNoteTime, bas[step % 16], stepDur*0.98, isFever ? feverGain : normalGain, 'sine');

            // tiny hi-hat tick
            if ((step % 2) === 0) {
              const o = audioCtx.createOscillator();
              const g = audioCtx.createGain();
              o.type = 'square';
              o.frequency.setValueAtTime(isFever ? 2200 : 1800, nextNoteTime);
              g.gain.setValueAtTime(0.0001, nextNoteTime);
              g.gain.exponentialRampToValueAtTime(isFever ? 0.06 : 0.05, nextNoteTime + 0.005);
              g.gain.exponentialRampToValueAtTime(0.0001, nextNoteTime + 0.03);
              o.connect(g); g.connect(isFever ? feverGain : normalGain);
              o.start(nextNoteTime);
              o.stop(nextNoteTime + 0.04);
            }

            nextNoteTime += stepDur;
            step++;
          }
        }

        function start() {
          if (timer) return;
          nextNoteTime = audioCtx.currentTime + 0.05;
          timer = setInterval(scheduler, interval);
        }

        function stop() {
          if (!timer) return;
          clearInterval(timer);
          timer = null;
          normalGain.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.03);
          feverGain.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.03);
        }

        function setEnabled(v) {
          enabled = v;
          if (!enabled) stop();
          else start();
        }

        function setMode(newMode) {
          mode = newMode;
          const t = audioCtx.currentTime;
          if (mode === 'fever') {
            normalGain.gain.setTargetAtTime(0.0, t, 0.06);
            feverGain.gain.setTargetAtTime(1.0, t, 0.06);
          } else {
            feverGain.gain.setTargetAtTime(0.0, t, 0.06);
            normalGain.gain.setTargetAtTime(1.0, t, 0.06);
          }
        }

        return { start, stop, setEnabled, setMode };
      })();

      function setMusicEnabled(on) {
        if (!music) return;
        if (!on) music.setEnabled(false);
        else {
          music.setEnabled(true);
          music.setMode(fever ? 'fever' : 'normal');
        }
      }

      // Helpers
      function rand(a,b){ return a + Math.random()*(b-a); }
      function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

      function detectDeviceType() {
        const touchPoints = navigator.maxTouchPoints || 0;
        const coarsePointer = coarsePointerQuery.matches;
        const width = window.innerWidth;
        const dpr = window.devicePixelRatio || 1;
        const touchCapable = touchPoints > 0 || coarsePointer;

        if ((touchCapable && width <= 760) || width <= 430) return 'mobile';
        if ((touchCapable && width <= 1180) || (width <= 1024 && dpr >= 1.25)) return 'tablet';
        return 'desktop';
      }

      function applyResponsiveProfile() {
        const width = window.innerWidth;
        const dpr = window.devicePixelRatio || 1;
        const coarsePointer = coarsePointerQuery.matches;
        const reducedMotion = reducedMotionQuery.matches;
        const deviceType = detectDeviceType();
        const preset = DEVICE_PRESETS[deviceType];

        const dprFxPenalty = dpr >= 3 ? 0.90 : dpr >= 2 ? 0.95 : 1.0;
        const reducedFxMul = reducedMotion
          ? (deviceType === 'mobile' ? 0.50 : deviceType === 'tablet' ? 0.58 : 0.64)
          : 1.0;
        const motionScale = reducedMotion ? (deviceType === 'mobile' ? 0.45 : 0.55) : 1.0;
        const hudScale = clamp(preset.hudScale * (coarsePointer ? 1.02 : 1.0), 0.78, 1.08);
        const uiScale = clamp(preset.uiScale * (coarsePointer ? 1.01 : 1.0), 0.80, 1.10);
        const fx = clamp(preset.fxDensity * dprFxPenalty * reducedFxMul, 0.18, 1.00);
        const pauseScale = clamp(preset.pauseScale * motionScale, 0.62, 1.02);
        const tapTargetPx = Math.max(preset.tapTarget, coarsePointer ? 44 : preset.tapTarget);
        const hudTop = width <= 680 ? 20 : 14;
        const hudSide = width <= 680 ? 10 : 14;

        root.dataset.device = deviceType;
        root.dataset.motion = reducedMotion ? 'reduced' : 'full';

        root.style.setProperty('--ui-scale', uiScale.toFixed(3));
        root.style.setProperty('--hud-scale', hudScale.toFixed(3));
        root.style.setProperty('--title-scale', preset.titleScale.toFixed(3));
        root.style.setProperty('--fx-density', fx.toFixed(3));
        root.style.setProperty('--fruit-scale', preset.fruitScale.toFixed(3));
        root.style.setProperty('--basket-scale', preset.basketScale.toFixed(3));
        root.style.setProperty('--pause-scale', pauseScale.toFixed(3));
        root.style.setProperty('--motion-scale', motionScale.toFixed(3));
        root.style.setProperty('--tap-target', `${tapTargetPx}px`);
        root.style.setProperty('--hud-inset-top', `${hudTop}px`);
        root.style.setProperty('--hud-inset-side', `${hudSide}px`);

        fxDensity = fx;
        particleDensity = clamp(fx * (reducedMotion ? 0.65 : 0.92), 0.14, 1.06);
        backgroundMotionScale = clamp(motionScale * (reducedMotion ? 0.88 : 1.00), 0.32, 1.00);
        rotationMotionScale = clamp(motionScale * (reducedMotion ? 0.78 : 1.00), 0.28, 1.00);
        pausePanelScale = pauseScale;
        floatTextScale = clamp(uiScale, 0.82, 1.05);

        const prevMinX = basket.w / 2 + 14;
        const prevMaxX = canvas.width - basket.w / 2 - 14;
        const prevSpan = Math.max(1, prevMaxX - prevMinX);
        const normalizedX = clamp((basket.x - prevMinX) / prevSpan, 0, 1);

        basket.w = BASE_BASKET_W * preset.basketScale;
        basket.h = BASE_BASKET_H * preset.basketScale;

        const minX = basket.w / 2 + 14;
        const maxX = canvas.width - basket.w / 2 - 14;
        basket.x = minX + normalizedX * Math.max(1, maxX - minX);
        basket.targetX = basket.targetX == null ? null : clamp(basket.targetX, minX, maxX);

        fruitRadiusMin = BASE_FRUIT_RADIUS_MIN * preset.fruitScale;
        fruitRadiusMax = BASE_FRUIT_RADIUS_MAX * preset.fruitScale;
      }

      let responsiveRaf = null;
      function scheduleResponsiveProfileApply() {
        if (responsiveRaf != null) return;
        responsiveRaf = requestAnimationFrame(() => {
          responsiveRaf = null;
          applyResponsiveProfile();
        });
      }

      function updateHearts() {
        heartsEl.innerHTML = '';
        for (let i=0;i<MAX_MISSES;i++){
          const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
          svg.setAttribute('viewBox','0 0 24 24');
          svg.setAttribute('class','heart');
          svg.innerHTML = `<path fill="${i < (MAX_MISSES - misses) ? '#ff4d6d' : '#cbd5e1'}"
            d="M12 21s-7.05-4.35-9.33-8.28C.5 9.2 2.12 5.9 5.55 5.15c1.82-.4 3.69.27 4.83 1.69C11.52 5.42 13.39 4.75 15.2 5.15c3.43.75 5.05 4.05 2.88 7.57C19.05 16.65 12 21 12 21z"/>`;
          heartsEl.appendChild(svg);
        }
      }

      function resetOverlayTextToStart() {
        overlay.querySelector('.title').textContent = '🍓 フルーツキャッチ';
        overlay.querySelector('.subtitle').textContent = 'カゴを動かして、フルーツをキャッチしよう！';
        overlay.querySelector('.how').innerHTML =
          `← / → か A / D で移動<br/>
           マウスやタッチでも移動OK<br/>
           3回ミスでゲームオーバー<br/>
           ⭐を取るとフィーバー（得点2倍）`;
        startBtn.textContent = 'スタート！';
      }

      function resetState() {
        score = 0;
        misses = 0;
        objects.length = 0;
        pops.length = 0;
        floatTexts.length = 0;
        totalElapsed = 0;
        fever = false;
        feverEnd = 0;
        gameOver = false;
        paused = false;

        basket.x = canvas.width/2;
        basket.targetX = null;

        scoreEl.textContent = '0';
        speedMulEl.textContent = 'x1.00';
        updateHearts();

        pauseBtn.textContent = '一時停止';
        feverBadge.classList.remove('show');

        if (music && soundOn) {
          music.setEnabled(true);
          music.setMode('normal');
        }
      }

      function startGame() {
        overlay.classList.remove('show');
        resetState();
        running = true;

        if (audioCtx) audioCtx.resume?.();
        setMusicEnabled(soundOn);
      }

      function restartGame() {
        overlay.classList.remove('show');
        resetState();
        running = true;

        if (audioCtx) audioCtx.resume?.();
        setMusicEnabled(soundOn);
      }

      function togglePause() {
        if (!running || gameOver) return;
        paused = !paused;
        pauseBtn.textContent = paused ? '再開' : '一時停止';

        if (music) {
          if (paused) music.setEnabled(false);
          else setMusicEnabled(soundOn);
        }
      }

      function endGame() {
        gameOver = true;
        running = false;

        if (music) music.setEnabled(false);

        overlay.querySelector('.title').textContent = 'ゲームオーバー';
        overlay.querySelector('.subtitle').textContent = `スコア: ${score}`;
        overlay.querySelector('.how').innerHTML = `おつかれさま！<br/>もう一度遊ぶ？`;
        startBtn.textContent = 'もう一回';
        overlay.classList.add('show');
      }

      // Particles & float text
      function pop(x, y, color, n=14) {
        const count = Math.max(2, Math.round(n * particleDensity));
        const velocityScale = 0.70 + particleDensity * 0.50;
        const radiusScale = 0.75 + particleDensity * 0.35;
        for (let i=0;i<count;i++){
          pops.push({
            x, y,
            vx: (Math.random()*2-1) * 420 * velocityScale,
            vy: ((Math.random()*2-1) * 420 - 120) * velocityScale,
            r: (Math.random()*6 + 3) * radiusScale,
            life: 0.5 + Math.random()*0.22,
            t: 0,
            color
          });
        }
      }

      function addFloatText(x, y, text, color) {
        floatTexts.push({
          x, y,
          vy: -90,
          t: 0,
          life: 0.85,
          text,
          color
        });
      }

      // Collision (generous)
      function intersectsCircleRect(cx, cy, r, rx, ry, rw, rh) {
        const x = clamp(cx, rx, rx + rw);
        const y = clamp(cy, ry, ry + rh);
        const dx = cx - x;
        const dy = cy - y;
        return (dx*dx + dy*dy) <= r*r;
      }

      function intersectsObjBasket(o) {
        const bx = basket.x - basket.w/2;
        const by = basket.y - basket.h/2;
        const bw = basket.w;
        const bh = basket.h;
        const padX = 18;
        const padY = 10;
        return intersectsCircleRect(o.x, o.y, o.r, bx - padX, by - padY, bw + padX*2, bh + padY*2);
      }

      // Spawning
      let spawnTimer = 0;

      function globalSpeedMultiplier() {
        // every 30 sec +10%
        const steps = Math.floor(totalElapsed / 30);
        return Math.pow(1.10, steps);
      }

      function spawnObject() {
        const r = rand(fruitRadiusMin, fruitRadiusMax);
        const x = rand(r+18, canvas.width - r - 18);

        const isStar = Math.random() < STAR.chance;

        if (isStar) {
          objects.push({
            kind: 'star',
            emoji: STAR.emoji,
            x, y: -r - 10,
            r: r * 0.92,
            baseMul: 1.00,
            points: 0,
            color: '#ffd670',
            rot: rand(0, Math.PI*2),
            spin: rand(-2.8, 2.8),
            vyBase: baseFallSpeed() * 1.05
          });
          return;
        }

        const t = FRUITS[Math.floor(Math.random()*FRUITS.length)];
        objects.push({
          kind: 'fruit',
          emoji: t.emoji,
          x, y: -r - 10,
          r,
          baseMul: t.mul,
          points: t.points,
          color: t.color,
          rot: rand(0, Math.PI*2),
          spin: rand(-2.2, 2.2),
          vyBase: baseFallSpeed()
        });
      }

      // Drawing helpers
      function roundedRect(x,y,w,h,r){
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr,y);
        ctx.arcTo(x+w,y,x+w,y+h,rr);
        ctx.arcTo(x+w,y+h,x,y+h,rr);
        ctx.arcTo(x,y+h,x,y,rr);
        ctx.arcTo(x,y,x+w,y,rr);
        ctx.closePath();
      }

      function drawBackground() {
        const now = performance.now();
        const t = now * 0.0002 * backgroundMotionScale;
        const hillStep = Math.max(40, Math.round(56 / Math.max(0.35, fxDensity)));
        const confettiCount = Math.max(6, Math.round(26 * fxDensity));

        // Fever special glow
        if (fever) {
          const pulse = 0.5 + 0.5*Math.sin(now * 0.006 * backgroundMotionScale);
          ctx.save();
          ctx.globalAlpha = (0.14 + pulse * 0.14) * (0.6 + fxDensity * 0.4);
          const g = ctx.createLinearGradient(0,0,canvas.width,canvas.height);
          g.addColorStop(0,  '#ffd670');
          g.addColorStop(0.5,'#ff70a6');
          g.addColorStop(1,  '#9b5de5');
          ctx.fillStyle = g;
          ctx.fillRect(0,0,canvas.width,canvas.height);
          ctx.restore();
        }

        // Soft hills
        ctx.save();
        ctx.globalAlpha = 0.25;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.moveTo(0, canvas.height);
        for (let x=0; x<=canvas.width; x+=hillStep){
          const y = canvas.height - 80 - Math.sin(x*0.008 + t*3) * 18;
          ctx.lineTo(x, y);
        }
        ctx.lineTo(canvas.width, canvas.height);
        ctx.closePath();
        ctx.fill();

        ctx.globalAlpha = 0.18;
        ctx.beginPath();
        ctx.moveTo(0, canvas.height);
        for (let x=0; x<=canvas.width; x+=hillStep){
          const y = canvas.height - 35 - Math.sin(x*0.01 + t*2) * 12;
          ctx.lineTo(x, y);
        }
        ctx.lineTo(canvas.width, canvas.height);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // Confetti dots
        ctx.save();
        ctx.globalAlpha = (fever ? 0.32 : 0.22) * (0.45 + fxDensity * 0.55);
        for (let i=0;i<confettiCount;i++){
          const x = (i * 97 + (now * 0.05 * backgroundMotionScale)) % canvas.width;
          const y = 90 + (i * 53) % Math.max(220, Math.round(320 * (0.65 + fxDensity * 0.35)));
          ctx.beginPath();
          ctx.arc(x, y, (4 + (i%3)) * (0.75 + fxDensity * 0.25), 0, Math.PI*2);
          ctx.fillStyle = ['#ff70a6','#ffd670','#46d19f','#9b5de5','#ff9770'][i%5];
          ctx.fill();
        }
        ctx.restore();
      }

      function drawBasket() {
        const x = basket.x;
        const y = basket.y;
        const w = basket.w;
        const h = basket.h;

        ctx.save();
        ctx.translate(x, y);

        // Shadow
        ctx.globalAlpha = 0.22;
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(0, h*0.8, w*0.42, h*0.28, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;

        // Body
        ctx.fillStyle = '#ffffff';
        roundedRect(-w/2, -h/2, w, h, 18);
        ctx.fill();

        // Inside
        ctx.fillStyle = '#f1f5f9';
        roundedRect(-w/2+10, -h/2+10, w-20, h-20, 14);
        ctx.fill();

        // Candy stripes
        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        roundedRect(-w/2+10, -h/2+10, w-20, h-20, 14);
        ctx.clip();
        for (let i=-w; i<w; i+=26){
          ctx.fillStyle = (i/26)%2===0 ? '#ff70a6' : '#ffd670';
          ctx.beginPath();
          ctx.moveTo(i, -h);
          ctx.lineTo(i+12, -h);
          ctx.lineTo(i+w, h);
          ctx.lineTo(i+w-12, h);
          ctx.closePath();
          ctx.globalAlpha = 0.18;
          ctx.fill();
        }
        ctx.restore();

        // Handle
        ctx.strokeStyle = '#1f2937';
        ctx.lineWidth = 7;
        ctx.globalAlpha = 0.55;
        ctx.beginPath();
        ctx.arc(0, -h/2+4, w*0.28, Math.PI, 0);
        ctx.stroke();

        ctx.restore();
      }

      function drawObject(o) {
        ctx.save();
        ctx.translate(o.x, o.y);
        ctx.rotate(o.rot);

        // small shadow behind emoji
        ctx.globalAlpha = 0.18;
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(0, o.r*0.55, o.r*0.78, o.r*0.35, 0, 0, Math.PI*2);
        ctx.fill();

        // glow for star
        if (o.kind === 'star') {
          ctx.globalAlpha = 0.28;
          ctx.beginPath();
          ctx.arc(0, 0, o.r*1.35, 0, Math.PI*2);
          ctx.fillStyle = '#ffd670';
          ctx.fill();
        }

        ctx.globalAlpha = 1;
        ctx.font = `${Math.floor(o.r*1.65)}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(o.emoji, 0, 0);

        ctx.restore();
      }

      function drawParticles(dt) {
        for (let i=pops.length-1;i>=0;i--){
          const p = pops[i];
          p.t += dt;
          const k = 1 - (p.t / p.life);
          if (k <= 0) { pops.splice(i,1); continue; }
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vy += 980 * dt;

          const alpha = Math.max(0, k) * particleDensity;
          if (alpha <= 0.01) continue;
          ctx.globalAlpha = alpha * (fever ? 1.0 : 0.9);
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r * (0.52 + k * (0.48 + particleDensity * 0.25)), 0, Math.PI*2);
          ctx.fillStyle = p.color;
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }

      function drawFloatTexts(dt) {
        for (let i=floatTexts.length-1;i>=0;i--){
          const ft = floatTexts[i];
          ft.t += dt;
          const k = 1 - (ft.t / ft.life);
          if (k <= 0) { floatTexts.splice(i,1); continue; }
          ft.y += ft.vy * dt;

          ctx.save();
          ctx.globalAlpha = Math.max(0, k);
          const fontSize = Math.max(20, Math.round(28 * floatTextScale));
          ctx.font = `900 ${fontSize}px "M PLUS Rounded 1c","Zen Maru Gothic",system-ui,sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = '#ffffff';
          ctx.strokeStyle = 'rgba(31,41,55,.35)';
          ctx.lineWidth = Math.max(4, fontSize * 0.21);
          ctx.strokeText(ft.text, ft.x, ft.y);
          ctx.fillStyle = ft.color;
          ctx.fillText(ft.text, ft.x, ft.y);
          ctx.restore();
        }
      }

      // Main loop
      let last = performance.now();
      function frame(now) {
        const dt = Math.min(0.033, (now - last) / 1000);
        last = now;

        // Clear
        ctx.clearRect(0,0,canvas.width,canvas.height);

        // Background
        drawBackground();

        if (running && !paused) {
          totalElapsed += dt;

          // speed multiplier (every 30 sec +10%)
          const gMul = globalSpeedMultiplier();
          speedMulEl.textContent = `x${gMul.toFixed(2)}`;

          // Basket movement
          const left = keys.has('ArrowLeft') || keys.has('a') || keys.has('A');
          const right = keys.has('ArrowRight') || keys.has('d') || keys.has('D');

          if (left) basket.vx = -basket.speed;
          else if (right) basket.vx = basket.speed;
          else basket.vx *= 0.85;

          // Mouse target easing
          if (basket.targetX != null) {
            const dx = basket.targetX - basket.x;
            basket.x += dx * (1 - Math.pow(0.000001, dt));
          } else {
            basket.x += basket.vx * dt;
          }

          basket.x = clamp(basket.x, basket.w/2 + 14, canvas.width - basket.w/2 - 14);

          // Spawn
          spawnTimer += dt;
          if (spawnTimer >= spawnInterval()) {
            spawnTimer = 0;
            spawnObject();
          }

          // Fever timer UI & end
          if (fever) {
            const remain = Math.max(0, feverEnd - totalElapsed);
            feverTimeEl.textContent = `${remain.toFixed(1)}s`;
            if (remain <= 0) {
              fever = false;
              feverBadge.classList.remove('show');
              if (music && soundOn) music.setMode('normal');
              pop(canvas.width*0.5, canvas.height*0.22, '#ffffff', 18);
            }
          }

          // Update objects
          for (let i=objects.length-1;i>=0;i--){
            const o = objects[i];

            const vy = o.vyBase * o.baseMul * gMul;

            o.y += vy * dt;
            o.rot += o.spin * dt * rotationMotionScale;

            // Catch?
            if (intersectsObjBasket(o)) {
              objects.splice(i,1);

              if (o.kind === 'star') {
                // Fever start (20s), points x2
                fever = true;
                feverEnd = totalElapsed + FEVER_DURATION;
                feverBadge.classList.add('show');

                pop(o.x, o.y, '#ffd670', 24);
                pop(o.x, o.y, '#ff70a6', 18);
                addFloatText(o.x, o.y - 10, 'フィーバー！', '#ffd670');

                sfx('star');
                if (music && soundOn) music.setMode('fever');
                continue;
              }

              const basePts = o.points;
              const got = fever ? basePts * 2 : basePts;

              score += got;
              scoreEl.textContent = String(score);

              pop(o.x, o.y, o.color, fever ? 22 : 14);
              addFloatText(o.x, o.y - 12, `+${got}`, fever ? '#ffd670' : o.color);
              sfx('catch');
              continue;
            }

            // Missed?
            if (o.y - o.r > canvas.height + 10) {
              objects.splice(i,1);

              if (o.kind === 'star') continue;

              misses++;
              updateHearts();
              pop(clamp(o.x, 40, canvas.width-40), canvas.height-55, '#ff4d6d', 14);
              sfx('miss');

              if (misses >= MAX_MISSES) {
                endGame();
                break;
              }
            }
          }
        }

        // Draw objects
        for (const o of objects) drawObject(o);

        // Draw basket
        drawBasket();

        // Particles & float texts
        drawParticles(dt);
        drawFloatTexts(dt);

        // Pause label
        if (running && paused && !gameOver) {
          ctx.save();
          ctx.globalAlpha = 0.92;
          ctx.fillStyle = '#ffffff';
          const panelW = Math.min(canvas.width * 0.76, 380 * pausePanelScale);
          const panelH = Math.min(canvas.height * 0.34, 156 * pausePanelScale);
          const corner = Math.max(18, 26 * pausePanelScale);
          roundedRect(canvas.width/2 - panelW/2, canvas.height/2 - panelH/2, panelW, panelH, corner);
          ctx.fill();
          ctx.fillStyle = '#1f2937';
          const pauseFontSize = Math.max(30, Math.round(44 * pausePanelScale));
          ctx.font = `900 ${pauseFontSize}px "M PLUS Rounded 1c","Zen Maru Gothic",system-ui,sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('一時停止', canvas.width/2, canvas.height/2 + 1);
          ctx.restore();
        }

        requestAnimationFrame(frame);
      }

      // Init
      applyResponsiveProfile();
      window.addEventListener('resize', scheduleResponsiveProfileApply, {passive:true});
      window.addEventListener('orientationchange', scheduleResponsiveProfileApply, {passive:true});
      if (typeof reducedMotionQuery.addEventListener === 'function') {
        reducedMotionQuery.addEventListener('change', scheduleResponsiveProfileApply);
      } else if (typeof reducedMotionQuery.addListener === 'function') {
        reducedMotionQuery.addListener(scheduleResponsiveProfileApply);
      }
      if (typeof coarsePointerQuery.addEventListener === 'function') {
        coarsePointerQuery.addEventListener('change', scheduleResponsiveProfileApply);
      } else if (typeof coarsePointerQuery.addListener === 'function') {
        coarsePointerQuery.addListener(scheduleResponsiveProfileApply);
      }
      updateHearts();
      resetOverlayTextToStart();
      requestAnimationFrame(frame);

      // Start with overlay (music off until start)
      if (music) music.setEnabled(false);
    })();
  </script>
</body>
</html>
