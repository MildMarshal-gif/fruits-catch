<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>フルーツキャッチ</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Dela+Gothic+One&family=M+PLUS+Rounded+1c:wght@700;800;900&display=swap" rel="stylesheet">

  <style>
    :root{
      --sky-top:#57b8ff;
      --sky-mid:#9be8ff;
      --sky-bottom:#d8ffcb;
      --shell-ink:#203049;
      --shell-ink-soft:#4b627f;
      --panel:#fffdf4e8;
      --panel-strong:#fff9ec;
      --panel-border:#ffffffd1;
      --shadow-soft:0 10px 24px rgba(32,48,73,.18);
      --shadow-strong:0 24px 56px rgba(32,48,73,.28);
      --brand-pink:#ff5ba8;
      --brand-orange:#ff9e4d;
      --brand-gold:#ffd36a;
      --brand-green:#58d36b;
      --brand-blue:#56a8ff;
      --good:#2ecc98;
      --bad:#ff5f78;
      --fever-warm:#ffe38d;
      --fever-hot:#ff8abb;
      --fever-cool:#67b8ff;
      --ui-scale:1;
      --hud-scale:1;
      --title-scale:1;
      --fx-density:1;
      --fruit-scale:1;
      --basket-scale:1;
      --pause-scale:1;
      --motion-scale:1;
      --tap-target:44px;
      --hud-inset-top:14px;
      --hud-inset-side:14px;
      --text-leading:1.35;
      --shell-radius:32px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; }

    body{
      font-family:"M PLUS Rounded 1c","Hiragino Maru Gothic ProN","Yu Gothic UI","Meiryo",system-ui,sans-serif;
      display:grid;
      place-items:center;
      overflow:hidden;
      color:var(--shell-ink);
      background:
        radial-gradient(1300px 650px at -6% -8%, #ffffffc9 0 36%, transparent 37%),
        radial-gradient(1100px 560px at 108% 6%, #fff7d9bf 0 38%, transparent 39%),
        linear-gradient(180deg, var(--sky-top) 0%, var(--sky-mid) 54%, var(--sky-bottom) 100%);
    }

    body::before,
    body::after{
      content:"";
      position:fixed;
      inset:auto;
      pointer-events:none;
      z-index:0;
      opacity:.45;
      filter:blur(0.2px);
      animation:skyDrift 16s linear infinite;
    }

    body::before{
      width:min(44vw, 640px);
      height:min(24vw, 340px);
      left:-6vw;
      top:6vh;
      background:
        radial-gradient(circle at 18% 44%, #ffffffd8 0 20%, transparent 21%),
        radial-gradient(circle at 54% 50%, #ffffffda 0 26%, transparent 27%),
        radial-gradient(circle at 82% 44%, #ffffffd2 0 20%, transparent 21%);
    }

    body::after{
      width:min(36vw, 520px);
      height:min(20vw, 300px);
      right:-2vw;
      top:14vh;
      background:
        radial-gradient(circle at 20% 52%, #fff7dcdd 0 22%, transparent 23%),
        radial-gradient(circle at 56% 44%, #ffffffd1 0 28%, transparent 29%),
        radial-gradient(circle at 86% 58%, #fffce8d8 0 18%, transparent 19%);
      animation-duration:21s;
      animation-direction:reverse;
    }

    .wrap{
      width:min(1060px, 96vw);
      aspect-ratio:16 / 9;
      position:relative;
      z-index:1;
      overflow:hidden;
      border-radius:var(--shell-radius);
      border:2px solid #ffffffb3;
      box-shadow:var(--shadow-strong);
      background:
        linear-gradient(180deg, #ffffff54, #ffffff14),
        linear-gradient(155deg, #fff9ec77 0%, #ffffff10 56%, #d2efff21 100%);
      backdrop-filter:blur(8px);
    }

    .wrap::before{
      content:"";
      position:absolute;
      inset:0;
      background:
        radial-gradient(66% 48% at 10% 0%, #ffffff55 0, transparent 70%),
        radial-gradient(64% 46% at 90% 0%, #ffefbd33 0, transparent 72%);
      mix-blend-mode:screen;
      pointer-events:none;
    }

    canvas{
      width:100%;
      height:100%;
      display:block;
    }

    .hud{
      position:absolute;
      inset:
        calc(var(--hud-inset-top) + env(safe-area-inset-top))
        var(--hud-inset-side)
        auto
        var(--hud-inset-side);
      display:grid;
      grid-template-columns:minmax(0, 1fr) auto;
      gap:calc(10px * var(--hud-scale));
      align-items:start;
      pointer-events:none;
    }

    .hud-main{
      display:grid;
      grid-template-columns:repeat(2, minmax(0, 1fr));
      gap:calc(10px * var(--hud-scale));
      min-width:0;
    }

    .stat-card{
      min-height:calc(74px * var(--hud-scale));
      border-radius:20px;
      border:2px solid var(--panel-border);
      background:var(--panel);
      box-shadow:var(--shadow-soft);
      padding:calc(10px * var(--hud-scale)) calc(12px * var(--hud-scale));
      display:grid;
      gap:4px;
      align-content:center;
      min-width:0;
    }

    .stat-label{
      font-size:calc(12px * var(--hud-scale));
      line-height:1.1;
      font-weight:900;
      letter-spacing:.9px;
      text-transform:uppercase;
      color:var(--shell-ink-soft);
      opacity:.9;
    }

    .stat-value{
      display:inline-flex;
      align-items:center;
      gap:8px;
      min-width:0;
      font-weight:900;
      line-height:1;
      font-size:calc(30px * var(--hud-scale));
      color:var(--shell-ink);
    }

    .score-card .stat-value{
      color:#ff5b9c;
      text-shadow:0 2px 0 #ffffffbb;
    }

    .score-card.is-fever{
      border-color:#fff8d2;
      background:
        linear-gradient(118deg, #fff8db 0%, #ffe5ef 48%, #dff2ff 100%);
      box-shadow:
        0 0 0 1px #ffffffb8 inset,
        0 14px 28px rgba(32,48,73,.2),
        0 0 28px rgba(255,182,122,.34);
      animation:scoreFeverGlow 1.05s ease-in-out infinite;
    }

    .score-card.is-fever .stat-label{
      color:#8852bf;
      letter-spacing:1.2px;
    }

    #score{
      display:inline-block;
      min-width:2ch;
      transform-origin:center;
      transition:transform .09s linear, text-shadow .09s linear, color .18s ease;
      white-space:nowrap;
    }

    .hearts{
      display:flex;
      align-items:center;
      flex-wrap:nowrap;
      gap:calc(6px * var(--hud-scale));
      min-width:fit-content;
    }

    .life-heart{
      width:calc(24px * var(--hud-scale));
      height:calc(24px * var(--hud-scale));
      border-radius:8px;
      border:2px solid #e62f63;
      background:linear-gradient(180deg, #ffd8e5, #ffc0d9);
      color:#b61544;
      display:grid;
      place-items:center;
      font-size:calc(13px * var(--hud-scale));
      line-height:1;
      font-weight:900;
      box-shadow:0 5px 10px rgba(230,47,99,.18);
    }

    .life-heart.off{
      border-color:#93a4bd;
      background:linear-gradient(180deg, #edf1f8, #d9e1ee);
      color:#71839e;
      box-shadow:none;
    }

    .hearts.hit .life-heart.on{
      animation:lifeHitPulse .35s ease-out 2;
    }

    .hud-side{
      display:grid;
      gap:calc(8px * var(--hud-scale));
      justify-items:end;
      pointer-events:none;
    }

    .btns{
      display:flex;
      gap:calc(8px * var(--hud-scale));
      flex-wrap:wrap;
      justify-content:flex-end;
      pointer-events:auto;
    }

    button{
      cursor:pointer;
      border:none;
      border-radius:999px;
      min-height:var(--tap-target);
      min-width:var(--tap-target);
      padding:calc(10px * var(--ui-scale)) calc(16px * var(--ui-scale));
      font-family:inherit;
      font-size:calc(14px * var(--ui-scale));
      line-height:1.15;
      font-weight:900;
      color:var(--shell-ink);
      background:linear-gradient(180deg, #fffef9, #ffeeda);
      box-shadow:0 8px 18px rgba(32,48,73,.2);
      border:2px solid #ffffffd8;
      transition:transform .09s ease, box-shadow .15s ease, filter .15s ease;
      touch-action:manipulation;
    }

    button:hover{
      transform:translateY(-1px);
      box-shadow:0 12px 22px rgba(32,48,73,.24);
      filter:saturate(1.03);
    }

    button:active{ transform:translateY(1px) scale(.992); }

    button:disabled{
      opacity:.65;
      cursor:default;
      transform:none;
      box-shadow:0 4px 10px rgba(32,48,73,.14);
      filter:none;
    }

    button:focus-visible{
      outline:3px solid #245b99;
      outline-offset:2px;
    }

    .badge{
      display:none;
      align-items:center;
      gap:8px;
      padding:calc(10px * var(--hud-scale)) calc(12px * var(--hud-scale));
      border-radius:14px;
      background:var(--panel-strong);
      border:2px solid var(--panel-border);
      box-shadow:var(--shadow-soft);
      font-size:calc(14px * var(--hud-scale));
      line-height:1;
      font-weight:900;
      color:var(--shell-ink);
      pointer-events:none;
      max-width:min(76vw, 360px);
      width:fit-content;
    }

    .badge.show{ display:flex; }

    .badge .spark{
      font-size:calc(15px * var(--hud-scale));
      color:#ff8b4a;
      text-shadow:0 0 7px #ffed97;
    }

    .badge .badge-label{
      text-transform:uppercase;
      letter-spacing:.8px;
      opacity:.85;
    }

    .badge .badge-time{
      font-size:calc(18px * var(--hud-scale));
      color:#f25f9f;
      min-width:4ch;
      text-align:right;
    }

    .badge .badge-tail{
      opacity:.7;
      font-size:calc(12px * var(--hud-scale));
    }

    .badge.fever-neon{
      color:#2c3158;
      background:
        linear-gradient(115deg, #fff8de 0%, #ffeec4 40%, #ffe0ef 75%, #d9efff 100%);
      border-color:#fff7df;
      box-shadow:
        0 0 0 1px #ffffffb5 inset,
        0 8px 20px rgba(32,48,73,.18),
        0 0 20px rgba(255,197,132,.38);
      animation:feverBadgePulse 1.2s ease-in-out infinite;
    }

    .badge.fever-neon .badge-time{
      color:#ff4f95;
      text-shadow:0 0 8px rgba(255,142,182,.55);
    }

    .badge.fever-neon[data-phase="enter"]{ animation-duration:.9s; }
    .badge.fever-neon[data-phase="active"]{ animation-duration:1.25s; }
    .badge.fever-neon[data-phase="exit"]{ animation-duration:1.45s; opacity:.92; }

    .pause-panel{
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      opacity:0;
      pointer-events:none;
      transition:opacity .18s ease;
      background:
        radial-gradient(120% 68% at 30% 6%, #ffffff35 0%, transparent 58%),
        linear-gradient(180deg, rgba(10,20,36,0.24), rgba(10,20,36,0.62));
      z-index:3;
    }

    .pause-panel.show{
      opacity:1;
      pointer-events:auto;
    }

    .pause-card{
      width:min(520px, 92%);
      border-radius:28px;
      border:2px solid #ffffffd8;
      background:
        linear-gradient(165deg, #fffef8 0%, #ffeacd 54%, #ffe2f4 100%);
      box-shadow:var(--shadow-strong);
      padding:calc(20px * var(--ui-scale));
      text-align:center;
      color:#25405f;
    }

    .pause-title{
      margin:0;
      font-size:calc(32px * var(--title-scale));
      line-height:1.16;
      color:#294770;
      text-shadow:0 2px 0 #ffffffd5;
      font-family:"Dela Gothic One","M PLUS Rounded 1c",sans-serif;
    }

    .pause-desc{
      margin:12px 0 14px;
      font-size:calc(14px * var(--ui-scale));
      font-weight:900;
      color:#365a84;
    }

    .pause-actions{
      display:grid;
      grid-template-columns:repeat(2, minmax(0,1fr));
      gap:10px;
    }

    #resumeBtn{
      background:linear-gradient(100deg, #ff7cb8 0%, #ffc76a 52%, #ffe98f 100%);
      color:#1f3152;
    }

    #pauseRestartBtn{
      background:linear-gradient(180deg, #f6fbff, #e4f2ff);
      color:#24486a;
    }

    .overlay{
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      background:
        radial-gradient(130% 78% at 20% 0%, #ffffff50 0%, transparent 54%),
        linear-gradient(180deg, #15305022, #15305068 80%, #10273f82);
      backdrop-filter:blur(6px);
      opacity:0;
      pointer-events:none;
      transition:opacity .24s ease;
    }

    .overlay.show{ opacity:1; pointer-events:auto; }

    .card{
      width:min(600px, 92%);
      border-radius:30px;
      border:2px solid #ffffffde;
      padding:
        calc(24px * var(--ui-scale))
        calc(24px * var(--ui-scale))
        calc(18px * var(--ui-scale));
      background:
        radial-gradient(120% 60% at 0% 0%, #ffffffd8 0%, transparent 46%),
        linear-gradient(180deg, #fffdf4f8, #ffefd2ef 72%, #ffe5f0eb 100%);
      box-shadow:var(--shadow-strong);
      color:var(--shell-ink);
      text-align:center;
      line-height:var(--text-leading);
      overflow:auto;
      max-height:calc(100% - 28px - env(safe-area-inset-top) - env(safe-area-inset-bottom));
      -webkit-overflow-scrolling:touch;
    }

    .title{
      margin:0 0 calc(10px * var(--ui-scale));
      font-family:"Dela Gothic One","M PLUS Rounded 1c",sans-serif;
      font-size:calc(35px * var(--title-scale));
      line-height:1.15;
      color:#ff4e94;
      letter-spacing:.4px;
      text-shadow:0 3px 0 #ffffffd6;
    }

    .subtitle{
      margin:0 0 calc(14px * var(--ui-scale));
      font-size:calc(16px * var(--ui-scale));
      line-height:1.42;
      font-weight:900;
      color:#2f4b69;
    }

    .how{
      margin:0 0 calc(18px * var(--ui-scale));
      padding:calc(14px * var(--ui-scale)) calc(16px * var(--ui-scale));
      border-radius:20px;
      border:2px dashed #ffca7f;
      background:
        linear-gradient(90deg, #ffe5f2d9 0%, #fff1d5e0 45%, #e5ffdbe0 100%);
      font-size:calc(15px * var(--ui-scale));
      font-weight:900;
      line-height:1.52;
      color:#29435f;
    }

    .stack{
      display:flex;
      gap:calc(10px * var(--ui-scale));
      flex-wrap:wrap;
      justify-content:center;
      margin-top:calc(8px * var(--ui-scale));
    }

    .stack button{
      padding:calc(12px * var(--ui-scale)) calc(20px * var(--ui-scale));
    }

    #startBtn{
      background:linear-gradient(100deg, #ff67ad 0%, #ffb34c 50%, #ffe479 100%);
      color:#1f2f4b;
    }

    #soundBtn{
      background:linear-gradient(180deg, #f2f9ff, #dff1ff);
      color:#204463;
    }

    .note{
      font-size:calc(12px * var(--ui-scale));
      font-weight:900;
      color:#496683;
      opacity:.84;
      margin-top:calc(10px * var(--ui-scale));
      line-height:1.45;
    }

    :root[data-device="mobile"] .hud{
      grid-template-columns:1fr;
      gap:8px;
    }

    :root[data-device="mobile"] .hud-main{
      grid-template-columns:repeat(2, minmax(0,1fr));
    }

    :root[data-device="mobile"] .hud-side{
      justify-items:stretch;
    }

    :root[data-device="mobile"] .btns{
      justify-content:space-between;
      width:100%;
    }

    :root[data-device="mobile"] .badge{
      justify-self:flex-start;
      max-width:100%;
    }

    @media (max-width: 980px) {
      .wrap{
        width:min(100vw, 980px);
      }

      .hud-main{
        gap:8px;
      }

      .stat-card{
        min-height:calc(66px * var(--hud-scale));
      }
    }

    @media (max-width: 700px) {
      body{ place-items:stretch; }

      .wrap{
        width:100vw;
        height:100dvh;
        aspect-ratio:auto;
        border-radius:0;
      }

      .hud{
        inset:
          calc(8px + env(safe-area-inset-top))
          8px
          auto
          8px;
      }

      .hud-main{
        grid-template-columns:repeat(2, minmax(0,1fr));
        gap:6px;
      }

      .stat-card{
        border-radius:16px;
        padding:8px 9px;
      }

      .stat-label{
        font-size:11px;
      }

      .stat-value{
        font-size:24px;
      }

      .life-heart{
        width:22px;
        height:22px;
      }

      .btns button{
        flex:1 1 auto;
      }

      .card{
        width:min(640px, 95vw);
      }
    }

    @keyframes skyDrift{
      0%{ transform:translateX(0px); }
      50%{ transform:translateX(12px); }
      100%{ transform:translateX(0px); }
    }

    @keyframes feverBadgePulse{
      0%,100%{ transform:scale(1); filter:saturate(1); }
      50%{ transform:scale(1.03); filter:saturate(1.12); }
    }

    @keyframes scoreFeverGlow{
      0%,100%{ transform:translateY(0); filter:saturate(1); }
      50%{ transform:translateY(-1px); filter:saturate(1.16); }
    }

    @keyframes lifeHitPulse{
      0%{ transform:scale(1); }
      30%{ transform:scale(1.3); }
      70%{ transform:scale(.92); }
      100%{ transform:scale(1); }
    }

    @keyframes hudDamageShake{
      0%,100%{ transform:translate3d(0,0,0); }
      20%{ transform:translate3d(-6px,0,0); }
      40%{ transform:translate3d(5px,-1px,0); }
      60%{ transform:translate3d(-4px,1px,0); }
      80%{ transform:translate3d(3px,0,0); }
    }

    .wrap.damage{
      animation:hudDamageShake .32s ease-out;
    }

    @media (prefers-reduced-motion: reduce) {
      body::before,
      body::after,
      .badge.fever-neon{
        animation:none !important;
      }

      .overlay,
      button,
      #score{
        transition:none;
      }

      .score-card.is-fever{
        animation:none !important;
      }
    }
  </style>
</head>

<body>
  <div class="wrap" aria-label="フルーツキャッチゲーム">
    <canvas id="game" width="1280" height="720"></canvas>

    <div class="hud">
      <div class="hud-main">
        <div class="stat-card score-card" aria-label="スコア">
          <span class="stat-label">Score</span>
          <span class="stat-value"><span id="score">0</span></span>
        </div>

        <div class="stat-card" aria-label="ライフ">
          <span class="stat-label">Life</span>
          <span class="stat-value">
            <span class="hearts" id="hearts"></span>
          </span>
        </div>
      </div>

      <div class="hud-side">
        <div class="btns">
          <button id="pauseBtn" type="button">一時停止</button>
        </div>

        <div class="badge" id="feverBadge" aria-live="polite">
          <span class="spark" aria-hidden="true">✦</span>
          <span class="badge-label">Fever</span>
          <span id="feverTime" class="badge-time">20.0s</span>
          <span class="badge-tail">残り</span>
        </div>
      </div>
    </div>

    <div class="pause-panel" id="pausePanel" aria-hidden="true">
      <div class="pause-card">
        <h2 class="pause-title">一時停止</h2>
        <p class="pause-desc">続けるか、最初からやり直すか選んでね</p>
        <div class="pause-actions">
          <button id="pauseRestartBtn" type="button">リスタート</button>
          <button id="resumeBtn" type="button">再開</button>
        </div>
      </div>
    </div>

    <div class="overlay show" id="overlay">
      <div class="card">
        <h1 class="title">FRUIT CATCH</h1>
        <p class="subtitle">スマホでサッと遊べるフルーツキャッチ！</p>
        <div class="how">
          画面を左右になぞってカゴを移動<br/>
          指1本でOK（片手プレイ向け）<br/>
          3回ミスでゲームオーバー<br/>
          星を取るとフィーバーで得点2倍
        </div>
        <div class="stack">
          <button id="startBtn" type="button">スタート！</button>
          <button id="soundBtn" type="button">サウンド: オン</button>
        </div>
        <div class="note">右上の「一時停止」でいつでも止められる</div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      // UI
      const scoreEl = document.getElementById('score');
      const scoreCardEl = document.querySelector('.score-card');
      const heartsEl = document.getElementById('hearts');
      const wrapEl = document.querySelector('.wrap');
      const overlay = document.getElementById('overlay');
      const pausePanel = document.getElementById('pausePanel');
      const startBtn = document.getElementById('startBtn');
      const resumeBtn = document.getElementById('resumeBtn');
      const pauseRestartBtn = document.getElementById('pauseRestartBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const soundBtn = document.getElementById('soundBtn');
      const feverBadge = document.getElementById('feverBadge');
      const feverTimeEl = document.getElementById('feverTime');
      const root = document.documentElement;
      const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
      const coarsePointerQuery = window.matchMedia('(pointer:coarse)');

      const DEVICE_PRESETS = {
        mobile: {
          uiScale: 0.86,
          hudScale: 0.83,
          titleScale: 0.84,
          fxDensity: 0.56,
          fruitScale: 0.90,
          basketScale: 0.61,
          pauseScale: 0.78,
          tapTarget: 44
        },
        tablet: {
          uiScale: 0.95,
          hudScale: 0.91,
          titleScale: 0.93,
          fxDensity: 0.78,
          fruitScale: 0.95,
          basketScale: 0.96,
          pauseScale: 0.90,
          tapTarget: 42
        },
        desktop: {
          uiScale: 1.0,
          hudScale: 1.0,
          titleScale: 1.0,
          fxDensity: 1.0,
          fruitScale: 1.0,
          basketScale: 1.0,
          pauseScale: 1.0,
          tapTarget: 40
        }
      };

      const BASE_BASKET_W = 240;
      const BASE_BASKET_H = 62;
      const BASE_CANVAS_W = 1280;
      const BASE_CANVAS_H = 720;
      const BASE_FRUIT_RADIUS_MIN = 28;
      const BASE_FRUIT_RADIUS_MAX = 42;
      let fruitRadiusMin = BASE_FRUIT_RADIUS_MIN;
      let fruitRadiusMax = BASE_FRUIT_RADIUS_MAX;
      let fxDensity = 1;
      let particleDensity = 1;
      let backgroundMotionScale = 1;
      let rotationMotionScale = 1;
      let floatTextScale = 1;
      let drawFixScaleY = 1;

      // Game constants
      const MAX_MISSES = 3;

      // Basket (kid-friendly big)
      const basket = {
        w: BASE_BASKET_W,
        h: BASE_BASKET_H,
        x: BASE_CANVAS_W / 2,
        y: BASE_CANVAS_H - 90,
        vx: 0,
        speed: 1150, // px/s
        targetX: null
      };

      // Fruits (fixed size per species; faster falls are smaller)
      const FRUITS = [
        { kind:'banana',     mul:0.80, points: 8, color:'#ffd670' },
        { kind:'apple',      mul:0.88, points: 9, color:'#ff6b7d' },
        { kind:'orange',     mul:0.96, points:10, color:'#ffb24f' },
        { kind:'peach',      mul:1.04, points:10, color:'#ff9b82' },
        { kind:'strawberry', mul:1.12, points:11, color:'#ff5f92' },
        { kind:'grape',      mul:1.22, points:12, color:'#8f7cff' },
        { kind:'watermelon', mul:1.30, points:13, color:'#47ce8f' },
      ];

      const FRUIT_MUL_MIN = Math.min(...FRUITS.map((f) => f.mul));
      const FRUIT_MUL_MAX = Math.max(...FRUITS.map((f) => f.mul));

      // Special star
      const STAR = { kind:'star', color:'#ffd670' };
      const STAR_CHANCE_NORMAL = 0.08;
      const STAR_CHANCE_FEVER = 0.08;

      // Spawn rate & base fall speed (global progression will multiply)
      function spawnInterval() {
        // start ~0.85s -> later ~0.55s
        const t = Math.min(1, totalElapsed / 120);
        return 0.85 - t * 0.30;
      }
      function baseFallSpeed() {
        return 310; // base speed before multipliers
      }

      function getFruitRadiusForMul(mul) {
        const range = Math.max(0.0001, FRUIT_MUL_MAX - FRUIT_MUL_MIN);
        const t = clamp((mul - FRUIT_MUL_MIN) / range, 0, 1);
        return fruitRadiusMax - (fruitRadiusMax - fruitRadiusMin) * t;
      }

      // State
      let running = false;
      let paused = false;
      let gameOver = false;
      let score = 0;
      let misses = 0;

      // elapsed time for progression
      let totalElapsed = 0; // seconds

      // Fever
      let fever = false;
      let feverEnd = 0; // seconds (game time)
      const FEVER_DURATION = 20;
      const FEVER_ENTER_DURATION = 0.82;
      const FEVER_EXIT_DURATION = 0.56;

      const feverFx = {
        phase: 'idle', // idle | enter | active | exit
        phaseStart: 0,
        enterDuration: FEVER_ENTER_DURATION,
        exitDuration: FEVER_EXIT_DURATION,
        flash: 0,
        hitPulse: 0,
        originX: BASE_CANVAS_W * 0.5,
        originY: BASE_CANVAS_H * 0.35
      };
      let scorePulse = 0;
      let runtimeFxQuality = 1;

      // Entities
      const objects = []; // fruits & star
      const pops = [];
      const floatTexts = [];
      const feverShockwaves = [];
      const feverSparks = [];
      const feverHitBursts = [];
      const feverStreams = [];
      const shootingStars = [];

      let damageFlash = 0;
      let lifeFxTimeout = null;
      let shootingStarSpawnTimer = 0;

      // Input
      const keys = new Set();
      window.addEventListener('keydown', (e) => {
        if (['ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
        keys.add(e.key);
        if (e.key === ' ' && running && !gameOver) togglePause();
      });
      window.addEventListener('keyup', (e) => keys.delete(e.key));

      function setBasketByClientX(clientX) {
        const rect = canvas.getBoundingClientRect();
        const x = (clientX - rect.left) / rect.width * canvas.width;
        basket.targetX = clamp(x, basket.w/2 + 14, canvas.width - basket.w/2 - 14);
      }
      canvas.addEventListener('mousemove', (e) => setBasketByClientX(e.clientX));
      canvas.addEventListener('touchstart', (e) => {
        if (e.touches?.[0]) setBasketByClientX(e.touches[0].clientX);
      }, {passive:true});
      canvas.addEventListener('touchmove', (e) => {
        if (e.touches?.[0]) setBasketByClientX(e.touches[0].clientX);
      }, {passive:true});

      // Buttons
      startBtn.addEventListener('click', () => startGame());
      pauseBtn.addEventListener('click', () => setPaused(true));
      resumeBtn.addEventListener('click', () => setPaused(false));
      pauseRestartBtn.addEventListener('click', () => restartGame());

      // Audio (WebAudio synth BGM: normal & fever)
      const audioCtx = (() => {
        try { return new (window.AudioContext || window.webkitAudioContext)(); }
        catch { return null; }
      })();
      let soundOn = true;

      soundBtn.textContent = `サウンド: ${soundOn ? 'オン' : 'オフ'}`;

      soundBtn.addEventListener('click', async () => {
        soundOn = !soundOn;
        soundBtn.textContent = `サウンド: ${soundOn ? 'オン' : 'オフ'}`;
        if (audioCtx && soundOn) {
          try { await audioCtx.resume(); } catch {}
        }
        setMusicEnabled(soundOn);
      });

      function oneShotVoice({
        time,
        freq,
        duration,
        destination,
        type = 'triangle',
        gainPeak = 0.16,
        detune = 0,
        slideTo = null
      }) {
        if (!freq || !duration) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.detune.setValueAtTime(detune, time);
        osc.frequency.setValueAtTime(freq, time);
        if (slideTo && slideTo > 0) {
          osc.frequency.exponentialRampToValueAtTime(slideTo, time + duration * 0.88);
        }

        gain.gain.setValueAtTime(0.0001, time);
        gain.gain.exponentialRampToValueAtTime(gainPeak, time + duration * 0.16);
        gain.gain.exponentialRampToValueAtTime(0.0001, time + duration);

        osc.connect(gain);
        gain.connect(destination);
        osc.start(time);
        osc.stop(time + duration + 0.02);
      }

      // SFX
      function sfx(type='catch') {
        if (!audioCtx || !soundOn) return;
        const t0 = audioCtx.currentTime + 0.004;
        const out = audioCtx.createGain();
        out.gain.value = 0.24;
        out.connect(audioCtx.destination);

        const preset = type === 'miss'
          ? { notes:[280, 220, 160], step:0.034, dur:0.11, wave:'triangle', harmWave:'sine', harmMul:0.50, sparkle:false }
          : type === 'star'
            ? { notes:[740, 988, 1320, 1760], step:0.026, dur:0.13, wave:'triangle', harmWave:'square', harmMul:2.0, sparkle:true }
            : { notes:[560, 760, 960], step:0.024, dur:0.10, wave:'triangle', harmWave:'square', harmMul:1.5, sparkle:true };

        for (let i=0; i<preset.notes.length; i++) {
          const base = preset.notes[i];
          const t = t0 + i * preset.step;
          oneShotVoice({
            time:t,
            freq:base,
            duration:preset.dur,
            destination:out,
            type:preset.wave,
            gainPeak:type === 'miss' ? 0.11 : 0.14
          });
          oneShotVoice({
            time:t + 0.003,
            freq:base * preset.harmMul,
            duration:preset.dur * 0.68,
            destination:out,
            type:preset.harmWave,
            gainPeak:type === 'star' ? 0.09 : 0.06,
            detune:6
          });
        }

        if (preset.sparkle) {
          oneShotVoice({
            time:t0 + preset.step * 0.5,
            freq:type === 'star' ? 2480 : 2120,
            duration:type === 'star' ? 0.14 : 0.09,
            destination:out,
            type:'square',
            gainPeak:type === 'star' ? 0.075 : 0.05
          });
        }
      }

      // BGM sequencer
      const music = (() => {
        if (!audioCtx) return null;

        const master = audioCtx.createGain();
        master.gain.value = 0.2;
        master.connect(audioCtx.destination);

        const normalGain = audioCtx.createGain();
        const feverGain = audioCtx.createGain();
        normalGain.gain.value = 0.0;
        feverGain.gain.value = 0.0;
        normalGain.connect(master);
        feverGain.connect(master);

        let enabled = true;
        let mode = 'normal';
        let step = 0;
        let timer = null;
        let nextNoteTime = 0;

        const lookAhead = 0.13;
        const interval = 22;
        const bpmNormal = 124;
        const bpmFever = 152;

        const N = {
          C4:261.63, D4:293.66, E4:329.63, F4:349.23, G4:392.00, A4:440.00, B4:493.88,
          C5:523.25, D5:587.33, E5:659.25, F5:698.46, G5:783.99, A5:880.00, B5:987.77,
          C6:1046.5
        };

        const normalLead = [
          N.E5,N.G5,N.B5,N.G5, N.D5,N.F5,N.A5,N.F5,
          N.C5,N.E5,N.G5,N.E5, N.D5,N.F5,N.A5,N.G5
        ];
        const normalBass = [
          N.C4,0,N.C4,0, N.F4,0,N.F4,0,
          N.A4,0,N.A4,0, N.G4,0,N.G4,0
        ];
        const normalChime = [
          N.E6,0,0,N.B5, 0,N.A5,0,0,
          N.G5,0,0,N.E5, 0,N.D5,0,0
        ];

        const feverLead = [
          N.A5,N.C6,N.B5,N.G5, N.E5,N.G5,N.A5,N.B5,
          N.C6,N.B5,N.G5,N.E5, N.G5,N.A5,N.C6,N.B5
        ];
        const feverBass = [
          N.A4,0,N.A4,0, N.G4,0,N.G4,0,
          N.E4,0,N.E4,0, N.F4,0,N.F4,0
        ];
        const feverChime = [
          N.C6,0,N.B5,0, N.A5,0,N.G5,0,
          N.E5,0,N.G5,0, N.A5,0,N.B5,0
        ];

        function playPatternNote(time, freq, duration, gainNode, options = {}) {
          if (!freq) return;
          oneShotVoice({
            time,
            freq,
            duration,
            destination:gainNode,
            type:options.type || 'triangle',
            gainPeak:options.gainPeak ?? 0.12,
            detune:options.detune ?? 0,
            slideTo:options.slideTo ?? null
          });
        }

        function scheduler() {
          if (!enabled) return;
          const now = audioCtx.currentTime;

          while (nextNoteTime < now + lookAhead) {
            const isFever = mode === 'fever';
            const bpm = isFever ? bpmFever : bpmNormal;
            const stepDur = (60 / bpm) / 4;
            const lane = isFever ? feverGain : normalGain;
            const lead = isFever ? feverLead : normalLead;
            const bass = isFever ? feverBass : normalBass;
            const chime = isFever ? feverChime : normalChime;
            const idx = step % 16;

            playPatternNote(nextNoteTime, lead[idx], stepDur * 0.92, lane, {
              type:isFever ? 'sawtooth' : 'triangle',
              gainPeak:isFever ? 0.12 : 0.10,
              slideTo:isFever ? lead[idx] * 1.02 : null
            });

            playPatternNote(nextNoteTime, bass[idx], stepDur * 0.98, lane, {
              type:'sine',
              gainPeak:isFever ? 0.10 : 0.085,
              detune:-3
            });

            if ((step % 2) === 0) {
              playPatternNote(nextNoteTime + 0.004, chime[idx], stepDur * 0.55, lane, {
                type:'square',
                gainPeak:isFever ? 0.052 : 0.04,
                detune:8
              });
            }

            if ((step % 4) === 0) {
              playPatternNote(nextNoteTime, isFever ? 146 : 128, stepDur * 0.42, lane, {
                type:'sine',
                gainPeak:isFever ? 0.072 : 0.05
              });
            }

            nextNoteTime += stepDur;
            step++;
          }
        }

        function start() {
          if (timer) return;
          nextNoteTime = audioCtx.currentTime + 0.06;
          timer = setInterval(scheduler, interval);
        }

        function stop() {
          if (!timer) return;
          clearInterval(timer);
          timer = null;
          normalGain.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.03);
          feverGain.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.03);
        }

        function setEnabled(v) {
          enabled = v;
          if (!enabled) {
            stop();
            return;
          }
          start();
          setMode(mode);
        }

        function setMode(newMode) {
          mode = newMode;
          const t = audioCtx.currentTime;
          if (mode === 'fever') {
            normalGain.gain.setTargetAtTime(0.0, t, 0.05);
            feverGain.gain.setTargetAtTime(1.0, t, 0.05);
          } else {
            feverGain.gain.setTargetAtTime(0.0, t, 0.05);
            normalGain.gain.setTargetAtTime(1.0, t, 0.05);
          }
        }

        return { start, stop, setEnabled, setMode };
      })();

      function setMusicEnabled(on) {
        if (!music) return;
        if (!on) music.setEnabled(false);
        else {
          music.setEnabled(true);
          music.setMode(fever ? 'fever' : 'normal');
        }
      }

      // Helpers
      function rand(a,b){ return a + Math.random()*(b-a); }
      function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
      function easeOutCubic(t){ const p = clamp(t, 0, 1); return 1 - Math.pow(1 - p, 3); }
      function easeInCubic(t){ const p = clamp(t, 0, 1); return p * p * p; }
      function getRuntimeFxDensity() {
        return clamp(particleDensity * runtimeFxQuality, 0.12, 1.12);
      }

      function updateScoreCardState() {
        const hot = fever || feverFx.phase !== 'idle';
        scoreCardEl.classList.toggle('is-fever', hot);
      }

      function updatePausePanel() {
        const show = running && paused && !gameOver;
        pausePanel.classList.toggle('show', show);
        pausePanel.setAttribute('aria-hidden', show ? 'false' : 'true');
      }

      function triggerLifeDamageEffect() {
        damageFlash = clamp(damageFlash + 1, 0, 1.2);
        wrapEl.classList.remove('damage');
        heartsEl.classList.remove('hit');
        void wrapEl.offsetWidth;
        wrapEl.classList.add('damage');
        heartsEl.classList.add('hit');
        if (lifeFxTimeout) clearTimeout(lifeFxTimeout);
        lifeFxTimeout = setTimeout(() => {
          wrapEl.classList.remove('damage');
          heartsEl.classList.remove('hit');
          lifeFxTimeout = null;
        }, 360);
      }

      function updateScorePulseStyles() {
        const hot = fever || feverFx.phase !== 'idle';
        updateScoreCardState();
        if (scorePulse <= 0.001) {
          scoreEl.style.transform = 'scale(1)';
          scoreEl.style.textShadow = 'none';
          scoreEl.style.color = '';
          return;
        }
        const pulseGain = reducedMotionQuery.matches ? 0.62 : 1.0;
        const scale = 1 + scorePulse * (hot ? 0.22 : 0.12) * pulseGain;
        const glow = Math.round((hot ? 10 : 6) + scorePulse * (hot ? 16 : 10) * pulseGain);
        scoreEl.style.transform = `scale(${scale.toFixed(3)})`;
        scoreEl.style.textShadow = hot
          ? `0 0 ${glow}px rgba(255,214,122,.9), 0 0 ${Math.round(glow * 1.5)}px rgba(255,103,173,.45)`
          : `0 0 ${glow}px rgba(255,255,255,.45)`;
        scoreEl.style.color = hot ? '#ff437e' : '';
      }

      function clearFeverVisualState() {
        feverShockwaves.length = 0;
        feverSparks.length = 0;
        feverHitBursts.length = 0;
        shootingStars.length = 0;
        feverFx.phase = 'idle';
        feverFx.phaseStart = 0;
        feverFx.flash = 0;
        feverFx.hitPulse = 0;
        scorePulse = 0;
        updateScorePulseStyles();
        updateScoreCardState();
        feverBadge.dataset.phase = 'idle';
        feverBadge.classList.remove('fever-neon');
      }

      function rebuildFeverStreams() {
        feverStreams.length = 0;
        const density = getRuntimeFxDensity();
        const count = Math.max(6, Math.round((reducedMotionQuery.matches ? 8 : 16) * density));
        for (let i=0; i<count; i++) {
          feverStreams.push({
            lane: rand(0.15, 0.80),
            seed: Math.random() * 1000,
            speed: rand(0.58, 1.72),
            len: rand(64, 172),
            width: rand(1.2, 3.4),
            amp: rand(6, 20),
            tone: i % 3
          });
        }
      }

      function spawnFeverShockwave(x, y, type='entry') {
        if (type === 'entry') {
          const waveCount = Math.max(1, Math.round((reducedMotionQuery.matches ? 1 : 2) * getRuntimeFxDensity()));
          for (let i=0; i<waveCount; i++) {
            feverShockwaves.push({
              x, y,
              t: -i * 0.08,
              life: feverFx.enterDuration + 0.24 + i * 0.08,
              startR: 16 + i * 10,
              endR: Math.max(canvas.width, canvas.height) * (0.50 + i * 0.12),
              width: 18 - i * 5,
              color: i === 0 ? '255,255,255' : '255,211,106',
              mode: 'expand'
            });
          }
          return;
        }
        feverShockwaves.push({
          x, y,
          t: 0,
          life: feverFx.exitDuration + 0.18,
          startR: Math.max(canvas.width, canvas.height) * 0.46,
          endR: 24,
          width: 12,
          color: '255,255,255',
          mode: 'collapse'
        });
      }

      function spawnFeverEntrySparks(x, y) {
        const density = getRuntimeFxDensity();
        const count = Math.max(10, Math.round((reducedMotionQuery.matches ? 14 : 30) * density));
        for (let i=0; i<count; i++) {
          const angle = (Math.PI * 2 * i / count) + rand(-0.18, 0.18);
          const speed = rand(210, 640) * (0.52 + density * 0.48);
          feverSparks.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - rand(10, 56),
            t: 0,
            life: rand(0.34, 0.82),
            size: rand(2.0, 5.0),
            tone: i % 3,
            mode: 'burst'
          });
        }
      }

      function spawnFeverExitConverge() {
        const cx = canvas.width * 0.5;
        const cy = canvas.height * 0.32;
        const density = getRuntimeFxDensity();
        const count = Math.max(8, Math.round((reducedMotionQuery.matches ? 12 : 22) * density));
        for (let i=0; i<count; i++) {
          const edge = i % 4;
          let x = 0;
          let y = 0;
          if (edge === 0) { x = rand(0, canvas.width); y = -8; }
          if (edge === 1) { x = canvas.width + 8; y = rand(0, canvas.height); }
          if (edge === 2) { x = rand(0, canvas.width); y = canvas.height + 8; }
          if (edge === 3) { x = -8; y = rand(0, canvas.height); }
          const dx = cx - x;
          const dy = cy - y;
          const dist = Math.hypot(dx, dy) || 1;
          const speed = dist / rand(0.42, 0.76);
          feverSparks.push({
            x, y,
            vx: (dx / dist) * speed,
            vy: (dy / dist) * speed,
            t: 0,
            life: rand(0.46, 0.82),
            size: rand(1.8, 4.1),
            tone: i % 3,
            mode: 'converge'
          });
        }
      }

      function spawnShootingStar(intensity = 1) {
        const heading = rand(Math.PI * 0.80, Math.PI * 0.90);
        const speed = rand(620, 1060) * (reducedMotionQuery.matches ? 0.64 : 1) * (0.82 + intensity * 0.25);
        const len = rand(76, 168);
        shootingStars.push({
          x: rand(canvas.width * 0.08, canvas.width * 0.92),
          y: rand(-canvas.height * 0.2, canvas.height * 0.36),
          vx: Math.cos(heading) * speed,
          vy: Math.sin(heading) * speed,
          life: rand(0.42, 0.72),
          t: 0,
          len,
          width: rand(1.3, 2.9),
          tone: Math.random() > 0.5 ? '#9fd8ff' : '#ffe39a'
        });
      }

      function triggerFeverHitFeedback(x, y, color='#ffd670') {
        const density = getRuntimeFxDensity();
        const burstLife = reducedMotionQuery.matches ? 0.24 : 0.32;
        feverHitBursts.push({
          x, y,
          color,
          t: 0,
          life: burstLife,
          r0: 10,
          r1: 58
        });
        feverFx.hitPulse = clamp(feverFx.hitPulse + (reducedMotionQuery.matches ? 0.24 : 0.38), 0, 1.25);
        scorePulse = clamp(scorePulse + (fever ? 0.78 : 0.44), 0, 1.35);

        const sparkCount = Math.max(4, Math.round((reducedMotionQuery.matches ? 4 : 10) * density));
        for (let i=0; i<sparkCount; i++) {
          const angle = (Math.PI * 2 * i / sparkCount) + rand(-0.24, 0.24);
          const speed = rand(120, 340);
          feverSparks.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            t: 0,
            life: rand(0.16, 0.34),
            size: rand(1.2, 3.2),
            tone: i % 3,
            mode: 'hit'
          });
        }
      }

      function setFeverPhase(nextPhase, nowSec, originX = canvas.width * 0.5, originY = canvas.height * 0.35) {
        if (nextPhase === 'enter') {
          feverFx.phase = 'enter';
          feverFx.phaseStart = nowSec;
          feverFx.enterDuration = reducedMotionQuery.matches ? 0.64 : FEVER_ENTER_DURATION;
          feverFx.exitDuration = reducedMotionQuery.matches ? 0.44 : FEVER_EXIT_DURATION;
          feverFx.originX = originX;
          feverFx.originY = originY;
          feverFx.flash = reducedMotionQuery.matches ? 0.26 : 0.78;
          feverFx.hitPulse = reducedMotionQuery.matches ? 0.26 : 0.52;
          feverBadge.classList.add('show', 'fever-neon');
          feverBadge.dataset.phase = 'enter';
          spawnFeverShockwave(originX, originY, 'entry');
          spawnFeverEntrySparks(originX, originY);
          updateScoreCardState();
          return;
        }
        if (nextPhase === 'active') {
          feverFx.phase = 'active';
          feverFx.phaseStart = nowSec;
          feverBadge.classList.add('show', 'fever-neon');
          feverBadge.dataset.phase = 'active';
          updateScoreCardState();
          return;
        }
        if (nextPhase === 'exit') {
          feverFx.phase = 'exit';
          feverFx.phaseStart = nowSec;
          feverFx.flash = Math.max(feverFx.flash, reducedMotionQuery.matches ? 0.18 : 0.34);
          feverFx.hitPulse = Math.max(feverFx.hitPulse, reducedMotionQuery.matches ? 0.2 : 0.32);
          feverBadge.classList.add('show', 'fever-neon');
          feverBadge.dataset.phase = 'exit';
          spawnFeverShockwave(canvas.width * 0.5, canvas.height * 0.32, 'exit');
          spawnFeverExitConverge();
          updateScoreCardState();
          return;
        }
        feverFx.phase = 'idle';
        feverFx.phaseStart = nowSec;
        feverFx.flash = 0;
        feverFx.hitPulse = 0;
        feverBadge.dataset.phase = 'idle';
        feverBadge.classList.remove('fever-neon');
        if (!fever) feverBadge.classList.remove('show');
        updateScoreCardState();
      }

      function getFeverVisualState(nowSec) {
        if (feverFx.phase === 'idle') {
          return { phase:'idle', intensity:0, enterT:0, exitT:0 };
        }
        if (feverFx.phase === 'enter') {
          const t = clamp((nowSec - feverFx.phaseStart) / feverFx.enterDuration, 0, 1);
          const intensity = clamp(0.48 + easeOutCubic(t) * 0.56 + feverFx.hitPulse * 0.22, 0, 1.24);
          return { phase:'enter', intensity, enterT:t, exitT:0 };
        }
        if (feverFx.phase === 'active') {
          const intensity = clamp(0.88 + feverFx.hitPulse * 0.22, 0, 1.22);
          return { phase:'active', intensity, enterT:1, exitT:0 };
        }
        const t = clamp((nowSec - feverFx.phaseStart) / feverFx.exitDuration, 0, 1);
        const intensity = clamp((0.92 - easeInCubic(t) * 0.92) + feverFx.hitPulse * 0.16, 0, 1.0);
        return { phase:'exit', intensity, enterT:1, exitT:t };
      }

      function updateFeverEffects(dt) {
        const targetQuality = dt > 0.029 ? 0.68 : dt > 0.024 ? 0.84 : 1.0;
        runtimeFxQuality += (targetQuality - runtimeFxQuality) * Math.min(1, dt * 4.2);
        runtimeFxQuality = clamp(runtimeFxQuality, 0.58, 1.0);

        scorePulse = Math.max(0, scorePulse - dt * (reducedMotionQuery.matches ? 4.1 : 6.1));
        feverFx.hitPulse = Math.max(0, feverFx.hitPulse - dt * (reducedMotionQuery.matches ? 2.7 : 4.4));
        feverFx.flash = Math.max(0, feverFx.flash - dt * (reducedMotionQuery.matches ? 1.7 : 2.6));

        const state = getFeverVisualState(totalElapsed);
        if (feverFx.phase === 'enter' && state.enterT >= 1) {
          setFeverPhase('active', totalElapsed);
        } else if (feverFx.phase === 'exit' && state.exitT >= 1) {
          setFeverPhase('idle', totalElapsed);
        }

        const meteorActive = fever || state.intensity > 0.06;
        if (meteorActive) {
          shootingStarSpawnTimer += dt;
          const interval = reducedMotionQuery.matches ? 0.34 : (0.20 - state.intensity * 0.08);
          while (shootingStarSpawnTimer >= interval) {
            shootingStarSpawnTimer -= interval * rand(0.72, 1.08);
            spawnShootingStar(state.intensity);
          }
        } else {
          shootingStarSpawnTimer = 0;
        }

        for (let i=feverShockwaves.length-1; i>=0; i--) {
          const w = feverShockwaves[i];
          w.t += dt;
          if (w.t > w.life) feverShockwaves.splice(i, 1);
        }

        for (let i=feverSparks.length-1; i>=0; i--) {
          const s = feverSparks[i];
          s.t += dt;
          if (s.t > s.life) { feverSparks.splice(i, 1); continue; }
          if (s.mode !== 'converge') s.vy += 320 * dt;
          s.x += s.vx * dt;
          s.y += s.vy * dt;
        }

        for (let i=feverHitBursts.length-1; i>=0; i--) {
          feverHitBursts[i].t += dt;
          if (feverHitBursts[i].t > feverHitBursts[i].life) feverHitBursts.splice(i, 1);
        }

        for (let i=shootingStars.length-1; i>=0; i--) {
          const s = shootingStars[i];
          s.t += dt;
          s.x += s.vx * dt;
          s.y += s.vy * dt;
          if (s.t > s.life || s.x + s.len < -40 || s.y - s.len > canvas.height + 40) {
            shootingStars.splice(i, 1);
          }
        }

        updateScorePulseStyles();
      }

      function detectDeviceType() {
        const touchPoints = navigator.maxTouchPoints || 0;
        const coarsePointer = coarsePointerQuery.matches;
        const width = window.innerWidth;
        const dpr = window.devicePixelRatio || 1;
        const touchCapable = touchPoints > 0 || coarsePointer;

        if ((touchCapable && width <= 760) || width <= 430) return 'mobile';
        if ((touchCapable && width <= 1180) || (width <= 1024 && dpr >= 1.25)) return 'tablet';
        return 'desktop';
      }

      function applyResponsiveProfile() {
        const width = window.innerWidth;
        const dpr = window.devicePixelRatio || 1;
        const coarsePointer = coarsePointerQuery.matches;
        const reducedMotion = reducedMotionQuery.matches;
        const prevCanvasW = canvas.width;
        const prevCanvasH = canvas.height;
        const canvasRect = canvas.getBoundingClientRect();
        const nextCanvasW = Math.max(320, Math.round(canvasRect.width || canvas.clientWidth || prevCanvasW));
        const nextCanvasH = Math.max(180, Math.round(canvasRect.height || canvas.clientHeight || prevCanvasH));
        const deviceType = detectDeviceType();
        const preset = DEVICE_PRESETS[deviceType];
        const targetCanvasW = deviceType === 'desktop' ? BASE_CANVAS_W : nextCanvasW;
        const targetCanvasH = deviceType === 'desktop' ? BASE_CANVAS_H : nextCanvasH;

        if (targetCanvasW !== prevCanvasW || targetCanvasH !== prevCanvasH) {
          const scaleX = targetCanvasW / prevCanvasW;
          const scaleY = targetCanvasH / prevCanvasH;
          canvas.width = targetCanvasW;
          canvas.height = targetCanvasH;

          if (Number.isFinite(scaleX) && Number.isFinite(scaleY) && scaleX > 0 && scaleY > 0) {
            basket.x *= scaleX;
            if (basket.targetX != null) basket.targetX *= scaleX;
            for (const o of objects) {
              o.x *= scaleX;
              o.y *= scaleY;
              o.r *= Math.min(scaleX, scaleY);
            }
            for (const p of pops) {
              p.x *= scaleX;
              p.y *= scaleY;
            }
            for (const ft of floatTexts) {
              ft.x *= scaleX;
              ft.y *= scaleY;
            }
            for (const w of feverShockwaves) {
              w.x *= scaleX;
              w.y *= scaleY;
              w.startR *= Math.min(scaleX, scaleY);
              w.endR *= Math.min(scaleX, scaleY);
              w.width *= Math.min(scaleX, scaleY);
            }
            for (const s of feverSparks) {
              s.x *= scaleX;
              s.y *= scaleY;
            }
            for (const hb of feverHitBursts) {
              hb.x *= scaleX;
              hb.y *= scaleY;
              hb.r0 *= Math.min(scaleX, scaleY);
              hb.r1 *= Math.min(scaleX, scaleY);
            }
            feverFx.originX *= scaleX;
            feverFx.originY *= scaleY;
          }
        }

        const dprFxPenalty = dpr >= 3 ? 0.90 : dpr >= 2 ? 0.95 : 1.0;
        const reducedFxMul = reducedMotion
          ? (deviceType === 'mobile' ? 0.50 : deviceType === 'tablet' ? 0.58 : 0.64)
          : 1.0;
        const motionScale = reducedMotion ? (deviceType === 'mobile' ? 0.45 : 0.55) : 1.0;
        const hudScale = clamp(preset.hudScale * (coarsePointer ? 1.02 : 1.0), 0.78, 1.08);
        const uiScale = clamp(preset.uiScale * (coarsePointer ? 1.01 : 1.0), 0.80, 1.10);
        const fx = clamp(preset.fxDensity * dprFxPenalty * reducedFxMul, 0.18, 1.00);
        const pauseScale = clamp(preset.pauseScale * motionScale, 0.62, 1.02);
        const tapTargetPx = Math.max(preset.tapTarget, coarsePointer ? 44 : preset.tapTarget);
        const hudTop = width <= 700 ? 10 : 14;
        const hudSide = width <= 700 ? 8 : 14;

        root.dataset.device = deviceType;
        root.dataset.motion = reducedMotion ? 'reduced' : 'full';

        root.style.setProperty('--ui-scale', uiScale.toFixed(3));
        root.style.setProperty('--hud-scale', hudScale.toFixed(3));
        root.style.setProperty('--title-scale', preset.titleScale.toFixed(3));
        root.style.setProperty('--fx-density', fx.toFixed(3));
        root.style.setProperty('--fruit-scale', preset.fruitScale.toFixed(3));
        root.style.setProperty('--basket-scale', preset.basketScale.toFixed(3));
        root.style.setProperty('--pause-scale', pauseScale.toFixed(3));
        root.style.setProperty('--motion-scale', motionScale.toFixed(3));
        root.style.setProperty('--tap-target', `${tapTargetPx}px`);
        root.style.setProperty('--hud-inset-top', `${hudTop}px`);
        root.style.setProperty('--hud-inset-side', `${hudSide}px`);

        fxDensity = fx;
        particleDensity = clamp(fx * (reducedMotion ? 0.65 : 0.92), 0.14, 1.06);
        backgroundMotionScale = clamp(motionScale * (reducedMotion ? 0.88 : 1.00), 0.32, 1.00);
        rotationMotionScale = clamp(motionScale * (reducedMotion ? 0.78 : 1.00), 0.28, 1.00);
        floatTextScale = clamp(uiScale, 0.82, 1.05);
        rebuildFeverStreams();

        const prevMinX = basket.w / 2 + 14;
        const prevMaxX = canvas.width - basket.w / 2 - 14;
        const prevSpan = Math.max(1, prevMaxX - prevMinX);
        const normalizedX = clamp((basket.x - prevMinX) / prevSpan, 0, 1);

        basket.w = BASE_BASKET_W * preset.basketScale;
        basket.h = BASE_BASKET_H * preset.basketScale;
        basket.y = canvas.height - Math.max(76, canvas.height * 0.125);

        const minX = basket.w / 2 + 14;
        const maxX = canvas.width - basket.w / 2 - 14;
        basket.x = minX + normalizedX * Math.max(1, maxX - minX);
        basket.targetX = basket.targetX == null ? null : clamp(basket.targetX, minX, maxX);

        fruitRadiusMin = BASE_FRUIT_RADIUS_MIN * preset.fruitScale;
        fruitRadiusMax = BASE_FRUIT_RADIUS_MAX * preset.fruitScale;
      }

      let responsiveRaf = null;
      function scheduleResponsiveProfileApply() {
        if (responsiveRaf != null) return;
        responsiveRaf = requestAnimationFrame(() => {
          responsiveRaf = null;
          applyResponsiveProfile();
        });
      }

      function updateDrawFixScale() {
        const rect = canvas.getBoundingClientRect();
        if (!rect.width || !rect.height || !canvas.width || !canvas.height) {
          drawFixScaleY = 1;
          return;
        }
        const sx = rect.width / canvas.width;
        const sy = rect.height / canvas.height;
        if (!sx || !sy) {
          drawFixScaleY = 1;
          return;
        }
        drawFixScaleY = clamp(sx / sy, 0.55, 1.65);
      }

      function updateHearts() {
        heartsEl.innerHTML = '';
        for (let i=0;i<MAX_MISSES;i++){
          const heart = document.createElement('span');
          const alive = i < (MAX_MISSES - misses);
          heart.setAttribute('class', `life-heart ${alive ? 'on' : 'off'}`);
          heart.textContent = '♥';
          heart.setAttribute('aria-hidden', 'true');
          heartsEl.appendChild(heart);
        }
        heartsEl.setAttribute('aria-label', `ライフ ${Math.max(0, MAX_MISSES - misses)} / ${MAX_MISSES}`);
      }

      function resetOverlayTextToStart() {
        overlay.querySelector('.title').textContent = 'FRUIT CATCH';
        overlay.querySelector('.subtitle').textContent = 'スマホでサッと遊べるフルーツキャッチ！';
        overlay.querySelector('.how').innerHTML =
          `画面を左右になぞってカゴを移動<br/>
           指1本でOK（片手プレイ向け）<br/>
           3回ミスでゲームオーバー<br/>
           星を取るとフィーバーで得点2倍`;
        startBtn.textContent = 'スタート！';
      }

      function resetState() {
        score = 0;
        misses = 0;
        objects.length = 0;
        pops.length = 0;
        floatTexts.length = 0;
        shootingStars.length = 0;
        totalElapsed = 0;
        fever = false;
        feverEnd = 0;
        gameOver = false;
        paused = false;
        damageFlash = 0;
        shootingStarSpawnTimer = 0;
        if (lifeFxTimeout) {
          clearTimeout(lifeFxTimeout);
          lifeFxTimeout = null;
        }
        wrapEl.classList.remove('damage');
        heartsEl.classList.remove('hit');

        basket.x = canvas.width/2;
        basket.y = canvas.height - Math.max(76, canvas.height * 0.125);
        basket.targetX = null;

        scoreEl.textContent = '0';
        feverTimeEl.textContent = `${FEVER_DURATION.toFixed(1)}s`;
        updateHearts();

        pauseBtn.disabled = false;
        clearFeverVisualState();
        feverBadge.classList.remove('show');
        updateScoreCardState();
        updatePausePanel();

        if (music && soundOn) {
          music.setEnabled(true);
          music.setMode('normal');
        }
      }

      function startGame() {
        overlay.classList.remove('show');
        resetState();
        running = true;
        updatePausePanel();

        if (audioCtx) audioCtx.resume?.();
        setMusicEnabled(soundOn);
      }

      function restartGame() {
        overlay.classList.remove('show');
        resetState();
        running = true;
        updatePausePanel();

        if (audioCtx) audioCtx.resume?.();
        setMusicEnabled(soundOn);
      }

      function setPaused(nextPaused) {
        if (!running || gameOver) return;
        paused = !!nextPaused;
        pauseBtn.textContent = '一時停止';
        pauseBtn.disabled = paused;
        updatePausePanel();

        if (music) {
          if (paused) music.setEnabled(false);
          else setMusicEnabled(soundOn);
        }
      }

      function togglePause() {
        if (!running || gameOver) return;
        setPaused(!paused);
      }

      function endGame() {
        gameOver = true;
        running = false;
        paused = false;
        pauseBtn.disabled = false;
        fever = false;
        clearFeverVisualState();
        feverBadge.classList.remove('show');
        updatePausePanel();

        if (music) music.setEnabled(false);

        overlay.querySelector('.title').textContent = 'ゲームオーバー';
        overlay.querySelector('.subtitle').textContent = `スコア: ${score}`;
        overlay.querySelector('.how').innerHTML = `おつかれさま！<br/>もう一度遊ぶ？`;
        startBtn.textContent = 'もう一回';
        overlay.classList.add('show');
      }

      // Particles & float text
      function pop(x, y, color, n=14) {
        const count = Math.max(2, Math.round(n * particleDensity));
        const velocityScale = 0.70 + particleDensity * 0.50;
        const radiusScale = 0.75 + particleDensity * 0.35;
        for (let i=0;i<count;i++){
          pops.push({
            x, y,
            vx: (Math.random()*2-1) * 420 * velocityScale,
            vy: ((Math.random()*2-1) * 420 - 120) * velocityScale,
            r: (Math.random()*6 + 3) * radiusScale,
            life: 0.5 + Math.random()*0.22,
            t: 0,
            color
          });
        }
      }

      function addFloatText(x, y, text, color) {
        floatTexts.push({
          x, y,
          vy: -90,
          t: 0,
          life: 0.85,
          text,
          color
        });
      }

      // Collision (generous)
      function intersectsCircleRect(cx, cy, r, rx, ry, rw, rh) {
        const x = clamp(cx, rx, rx + rw);
        const y = clamp(cy, ry, ry + rh);
        const dx = cx - x;
        const dy = cy - y;
        return (dx*dx + dy*dy) <= r*r;
      }

      function intersectsObjBasket(o) {
        const bx = basket.x - basket.w/2;
        const by = basket.y - basket.h/2;
        const bw = basket.w;
        const bh = basket.h;
        const padX = 18;
        const padY = 10;
        return intersectsCircleRect(o.x, o.y, o.r, bx - padX, by - padY, bw + padX*2, bh + padY*2);
      }

      // Spawning
      let spawnTimer = 0;

      function globalSpeedMultiplier() {
        // every 30 sec +10%
        const steps = Math.floor(totalElapsed / 30);
        return Math.pow(1.10, steps);
      }

      function spawnObject() {
        const starChance = fever ? STAR_CHANCE_FEVER : STAR_CHANCE_NORMAL;
        const isStar = Math.random() < starChance;

        if (isStar) {
          const r = clamp((fruitRadiusMin + fruitRadiusMax) * 0.44, 18, 36);
          const x = rand(r + 18, canvas.width - r - 18);
          objects.push({
            kind: 'star',
            fruitKind: STAR.kind,
            x, y: -r - 10,
            r,
            baseMul: 1.00,
            points: 0,
            color: STAR.color,
            rot: rand(0, Math.PI*2),
            spin: rand(-2.8, 2.8),
            vyBase: baseFallSpeed() * 1.05
          });
          return;
        }

        const t = FRUITS[Math.floor(Math.random()*FRUITS.length)];
        const r = getFruitRadiusForMul(t.mul);
        const x = rand(r + 18, canvas.width - r - 18);
        objects.push({
          kind: 'fruit',
          fruitKind: t.kind,
          x, y: -r - 10,
          r,
          baseMul: t.mul,
          points: t.points,
          color: t.color,
          rot: rand(0, Math.PI*2),
          spin: rand(-2.2, 2.2),
          vyBase: baseFallSpeed()
        });
      }

      // Drawing helpers
      function roundedRect(x,y,w,h,r){
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr,y);
        ctx.arcTo(x+w,y,x+w,y+h,rr);
        ctx.arcTo(x+w,y+h,x,y+h,rr);
        ctx.arcTo(x,y+h,x,y,rr);
        ctx.arcTo(x,y,x+w,y,rr);
        ctx.closePath();
      }

      function drawStarPath(outerR, innerR = outerR * 0.48) {
        ctx.beginPath();
        for (let i=0; i<10; i++) {
          const angle = -Math.PI / 2 + i * Math.PI / 5;
          const rr = (i % 2 === 0) ? outerR : innerR;
          const px = Math.cos(angle) * rr;
          const py = Math.sin(angle) * rr;
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
      }

      function getFruitStyle(fruitKind) {
        switch (fruitKind) {
          case 'banana':
            return {
              kind: 'banana',
              base: '#ffd65a',
              shade: '#f0ae29',
              highlight: '#fff3ad',
              stem: '#8d5e1c',
              leaf: '#63bf53'
            };
          case 'apple':
            return {
              kind: 'apple',
              base: '#ff5a6e',
              shade: '#c92f4d',
              highlight: '#ffbfbe',
              stem: '#6d4022',
              leaf: '#62b54d'
            };
          case 'orange':
            return {
              kind: 'orange',
              base: '#ffb046',
              shade: '#e67f25',
              highlight: '#ffd299',
              stem: '#7b4d27',
              leaf: '#5fb754'
            };
          case 'peach':
            return {
              kind: 'peach',
              base: '#ffb27f',
              shade: '#ff7f81',
              highlight: '#ffe2bc',
              stem: '#7e4a27',
              leaf: '#69bd53'
            };
          case 'strawberry':
            return {
              kind: 'strawberry',
              base: '#ff4c7e',
              shade: '#c82858',
              highlight: '#ff9fb9',
              stem: '#6f3f1f',
              leaf: '#62bf53',
              seed: '#ffe9b5'
            };
          case 'grape':
            return {
              kind: 'grape',
              base: '#8c72f2',
              shade: '#5f3fbb',
              highlight: '#ccbeff',
              stem: '#70411f',
              leaf: '#67b853',
              seed: '#d6c5ff'
            };
          case 'watermelon':
            return {
              kind: 'watermelon',
              base: '#4ecf87',
              shade: '#2d9f5b',
              highlight: '#95efbd',
              stem: '#70411f',
              leaf: '#65b753',
              seed: '#222334'
            };
          default:
            return {
              kind: 'orange',
              base: '#ffae54',
              shade: '#de7f2b',
              highlight: '#ffe0ad',
              stem: '#7b4d27',
              leaf: '#63b857'
            };
        }
      }

      function drawRoundFruit(style, r) {
        const body = ctx.createRadialGradient(-r*0.36, -r*0.45, r*0.15, 0, 0, r*1.15);
        body.addColorStop(0, style.highlight);
        body.addColorStop(0.58, style.base);
        body.addColorStop(1, style.shade);
        ctx.fillStyle = body;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = 'rgba(255,255,255,.35)';
        ctx.lineWidth = Math.max(1.6, r * 0.08);
        ctx.stroke();

        ctx.fillStyle = 'rgba(255,255,255,.34)';
        ctx.beginPath();
        ctx.ellipse(-r*0.34, -r*0.38, r*0.24, r*0.14, -0.6, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = style.stem;
        ctx.lineWidth = Math.max(2, r * 0.12);
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(-r*0.04, -r*0.88);
        ctx.quadraticCurveTo(0, -r*1.12, r*0.1, -r*0.96);
        ctx.stroke();

        ctx.fillStyle = style.leaf;
        ctx.beginPath();
        ctx.moveTo(r*0.02, -r*0.92);
        ctx.quadraticCurveTo(r*0.34, -r*1.06, r*0.36, -r*0.78);
        ctx.quadraticCurveTo(r*0.18, -r*0.68, r*0.02, -r*0.92);
        ctx.fill();
      }

      function drawApple(style, r) {
        const body = ctx.createRadialGradient(-r * 0.34, -r * 0.46, r * 0.16, 0, 0, r * 1.15);
        body.addColorStop(0, style.highlight);
        body.addColorStop(0.58, style.base);
        body.addColorStop(1, style.shade);
        ctx.fillStyle = body;

        ctx.beginPath();
        ctx.moveTo(0, -r * 0.92);
        ctx.bezierCurveTo(r * 0.72, -r * 1.02, r * 1.0, -r * 0.06, r * 0.52, r * 0.74);
        ctx.bezierCurveTo(r * 0.26, r * 0.98, -r * 0.26, r * 0.98, -r * 0.52, r * 0.74);
        ctx.bezierCurveTo(-r * 1.0, -r * 0.06, -r * 0.72, -r * 1.02, 0, -r * 0.92);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = 'rgba(255,255,255,.32)';
        ctx.beginPath();
        ctx.ellipse(-r * 0.3, -r * 0.35, r * 0.23, r * 0.14, -0.4, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = style.stem;
        ctx.lineWidth = Math.max(2, r * 0.12);
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(0, -r * 0.88);
        ctx.quadraticCurveTo(r * 0.04, -r * 1.16, r * 0.12, -r * 0.98);
        ctx.stroke();

        ctx.fillStyle = style.leaf;
        ctx.beginPath();
        ctx.moveTo(r * 0.10, -r * 0.94);
        ctx.quadraticCurveTo(r * 0.46, -r * 1.07, r * 0.42, -r * 0.76);
        ctx.quadraticCurveTo(r * 0.23, -r * 0.68, r * 0.10, -r * 0.94);
        ctx.fill();
      }

      function drawOrange(style, r) {
        drawRoundFruit(style, r);
        const dots = Math.max(12, Math.round(r * 0.45));
        ctx.fillStyle = 'rgba(255,203,127,.45)';
        for (let i=0; i<dots; i++) {
          const a = (Math.PI * 2 * i / dots) + (i % 2 ? 0.2 : -0.12);
          const rr = r * rand(0.14, 0.76);
          ctx.beginPath();
          ctx.arc(Math.cos(a) * rr, Math.sin(a) * rr, r * 0.04, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      function drawPeach(style, r) {
        const body = ctx.createRadialGradient(-r * 0.28, -r * 0.42, r * 0.12, 0, 0, r * 1.12);
        body.addColorStop(0, style.highlight);
        body.addColorStop(0.55, style.base);
        body.addColorStop(1, style.shade);
        ctx.fillStyle = body;

        ctx.beginPath();
        ctx.moveTo(0, -r * 0.88);
        ctx.bezierCurveTo(r * 0.74, -r * 0.84, r * 0.86, r * 0.10, 0, r * 0.96);
        ctx.bezierCurveTo(-r * 0.86, r * 0.10, -r * 0.74, -r * 0.84, 0, -r * 0.88);
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = 'rgba(255,126,136,.5)';
        ctx.lineWidth = Math.max(1.8, r * 0.08);
        ctx.beginPath();
        ctx.moveTo(0, -r * 0.58);
        ctx.quadraticCurveTo(-r * 0.1, 0, 0, r * 0.74);
        ctx.stroke();

        ctx.strokeStyle = style.stem;
        ctx.lineWidth = Math.max(2, r * 0.12);
        ctx.beginPath();
        ctx.moveTo(r * 0.02, -r * 0.9);
        ctx.quadraticCurveTo(r * 0.04, -r * 1.1, r * 0.14, -r * 0.92);
        ctx.stroke();

        ctx.fillStyle = style.leaf;
        ctx.beginPath();
        ctx.moveTo(r * 0.12, -r * 0.9);
        ctx.quadraticCurveTo(r * 0.42, -r * 1.03, r * 0.38, -r * 0.76);
        ctx.quadraticCurveTo(r * 0.20, -r * 0.68, r * 0.12, -r * 0.9);
        ctx.fill();
      }

      function drawBanana(style, r) {
        ctx.rotate(-0.42);

        ctx.strokeStyle = style.shade;
        ctx.lineWidth = r * 0.54;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.arc(0, 0, r * 0.78, Math.PI * 0.2, Math.PI * 1.1);
        ctx.stroke();

        const strip = ctx.createLinearGradient(-r, -r, r, r);
        strip.addColorStop(0, style.highlight);
        strip.addColorStop(0.55, style.base);
        strip.addColorStop(1, style.shade);
        ctx.strokeStyle = strip;
        ctx.lineWidth = r * 0.34;
        ctx.beginPath();
        ctx.arc(0, 0, r * 0.78, Math.PI * 0.2, Math.PI * 1.1);
        ctx.stroke();

        ctx.fillStyle = style.stem;
        ctx.beginPath();
        ctx.arc(-r*0.70, r*0.20, r*0.09, 0, Math.PI * 2);
        ctx.arc(r*0.36, -r*0.74, r*0.09, 0, Math.PI * 2);
        ctx.fill();
      }

      function drawStrawberry(style, r) {
        const body = ctx.createRadialGradient(-r*0.3, -r*0.48, r*0.12, 0, 0, r*1.08);
        body.addColorStop(0, style.highlight);
        body.addColorStop(0.6, style.base);
        body.addColorStop(1, style.shade);
        ctx.fillStyle = body;

        ctx.beginPath();
        ctx.moveTo(0, -r*0.95);
        ctx.bezierCurveTo(r*0.86, -r*0.82, r*0.9, r*0.24, 0, r*0.98);
        ctx.bezierCurveTo(-r*0.9, r*0.24, -r*0.86, -r*0.82, 0, -r*0.95);
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = 'rgba(255,255,255,.3)';
        ctx.lineWidth = Math.max(1.2, r * 0.07);
        ctx.stroke();

        const seeds = Math.max(10, Math.round(r * 0.33));
        ctx.fillStyle = style.seed;
        for (let i=0; i<seeds; i++) {
          const ang = (Math.PI * 2 * i / seeds) + (i % 2 ? 0.14 : -0.1);
          const rr = r * rand(0.28, 0.74);
          const sx = Math.cos(ang) * rr * 0.9;
          const sy = Math.sin(ang) * rr * 1.05 + r * 0.08;
          ctx.beginPath();
          ctx.ellipse(sx, sy, r*0.05, r*0.03, ang, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.fillStyle = style.leaf;
        for (let i=0; i<5; i++) {
          const a = -Math.PI * 0.84 + i * (Math.PI * 0.17);
          ctx.beginPath();
          ctx.moveTo(0, -r*0.72);
          ctx.quadraticCurveTo(
            Math.cos(a) * r * 0.36,
            -r*1.12 + Math.sin(a) * r * 0.08,
            Math.cos(a) * r * 0.18,
            -r*0.72
          );
          ctx.fill();
        }
      }

      function drawGrape(style, r) {
        const bubbles = [
          {x:0, y:r*0.04, s:0.46},
          {x:-r*0.34, y:r*0.08, s:0.34},
          {x:r*0.34, y:r*0.08, s:0.34},
          {x:-r*0.20, y:-r*0.24, s:0.32},
          {x:r*0.20, y:-r*0.24, s:0.32},
          {x:0, y:-r*0.42, s:0.31}
        ];

        for (let i=0; i<bubbles.length; i++) {
          const b = bubbles[i];
          const rr = r * b.s;
          const g = ctx.createRadialGradient(
            b.x - rr * 0.3,
            b.y - rr * 0.35,
            rr * 0.12,
            b.x,
            b.y,
            rr * 1.1
          );
          g.addColorStop(0, style.highlight);
          g.addColorStop(0.6, style.base);
          g.addColorStop(1, style.shade);
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(b.x, b.y, rr, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = 'rgba(255,255,255,.24)';
          ctx.lineWidth = Math.max(1, rr * 0.12);
          ctx.stroke();
        }

        ctx.strokeStyle = style.stem;
        ctx.lineWidth = Math.max(2, r * 0.11);
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(0, -r*0.88);
        ctx.quadraticCurveTo(r*0.06, -r*1.08, r*0.2, -r*0.92);
        ctx.stroke();

        ctx.fillStyle = style.leaf;
        ctx.beginPath();
        ctx.moveTo(r*0.1, -r*0.86);
        ctx.quadraticCurveTo(r*0.46, -r*1.0, r*0.42, -r*0.72);
        ctx.quadraticCurveTo(r*0.20, -r*0.62, r*0.1, -r*0.86);
        ctx.fill();
      }

      function drawWatermelon(style, r) {
        const body = ctx.createRadialGradient(-r*0.34, -r*0.44, r*0.12, 0, 0, r*1.1);
        body.addColorStop(0, style.highlight);
        body.addColorStop(0.58, style.base);
        body.addColorStop(1, style.shade);
        ctx.fillStyle = body;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.fill();

        ctx.save();
        ctx.beginPath();
        ctx.arc(0, 0, r * 0.92, 0, Math.PI * 2);
        ctx.clip();

        ctx.strokeStyle = 'rgba(26,128,63,.45)';
        ctx.lineWidth = Math.max(2, r * 0.12);
        for (let i=-2; i<=2; i++) {
          ctx.beginPath();
          ctx.moveTo(i * r * 0.34, -r * 0.9);
          ctx.quadraticCurveTo(i * r * 0.20, 0, i * r * 0.34, r * 0.9);
          ctx.stroke();
        }
        ctx.restore();

        ctx.strokeStyle = '#f5ffe5';
        ctx.lineWidth = Math.max(2, r * 0.1);
        ctx.beginPath();
        ctx.arc(0, 0, r * 0.92, 0, Math.PI * 2);
        ctx.stroke();

        ctx.fillStyle = style.seed;
        const seedCount = 6;
        for (let i=0; i<seedCount; i++) {
          const a = -Math.PI * 0.88 + i * (Math.PI * 0.35);
          const rr = r * (0.32 + (i % 2) * 0.14);
          ctx.save();
          ctx.translate(Math.cos(a) * rr, Math.sin(a) * rr);
          ctx.rotate(a + Math.PI / 2);
          ctx.beginPath();
          ctx.moveTo(0, -r*0.06);
          ctx.quadraticCurveTo(r*0.05, 0, 0, r*0.09);
          ctx.quadraticCurveTo(-r*0.05, 0, 0, -r*0.06);
          ctx.fill();
          ctx.restore();
        }
      }

      function drawFeverBackdrop(now, feverState, dynamicFx) {
        if (feverState.intensity <= 0.001) return;
        const intensity = feverState.intensity;
        const pulseFreq = reducedMotionQuery.matches ? 0.0043 : 0.0064;
        const pulse = 0.5 + 0.5 * Math.sin(now * pulseFreq * backgroundMotionScale + feverFx.hitPulse * 2.0);
        const centerX = feverFx.phase === 'enter' ? feverFx.originX : canvas.width * 0.5;
        const centerY = feverFx.phase === 'enter' ? feverFx.originY : canvas.height * 0.34;

        ctx.save();
        const warmWash = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        warmWash.addColorStop(0, 'rgba(88,136,255,.38)');
        warmWash.addColorStop(0.55, 'rgba(152,112,255,.33)');
        warmWash.addColorStop(1, 'rgba(89,232,255,.34)');
        ctx.globalAlpha = (0.10 + pulse * 0.10) * intensity;
        ctx.fillStyle = warmWash;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();

        ctx.save();
        const aura = ctx.createRadialGradient(
          centerX,
          centerY,
          Math.max(24, canvas.width * 0.03),
          centerX,
          centerY,
          canvas.width * 0.52
        );
        aura.addColorStop(0, 'rgba(235,246,255,0.62)');
        aura.addColorStop(0.24, 'rgba(141,213,255,0.42)');
        aura.addColorStop(0.56, 'rgba(188,140,255,0.22)');
        aura.addColorStop(1, 'rgba(103,184,255,0)');
        ctx.globalAlpha = (0.14 + pulse * 0.12) * intensity;
        ctx.fillStyle = aura;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();

        const streamAlpha = Math.min(0.34, (0.08 + intensity * 0.16) * (0.5 + dynamicFx * 0.5));
        if (streamAlpha > 0.01 && feverStreams.length) {
          const tones = ['#86d8ff', '#9ea7ff', '#ffd2fb'];
          ctx.save();
          ctx.globalCompositeOperation = 'lighter';
          for (let i=0; i<feverStreams.length; i++) {
            const s = feverStreams[i];
            const travel = ((now * 0.001 * (92 + s.speed * 86) * backgroundMotionScale) + s.seed * 0.73) % (canvas.width + s.len * 2);
            const x = travel - s.len;
            const y = canvas.height * s.lane + Math.sin(now * 0.0016 * s.speed + s.seed) * s.amp * (0.2 + intensity * 0.8);
            ctx.globalAlpha = streamAlpha * (0.6 + (s.tone % 3) * 0.14);
            ctx.strokeStyle = tones[s.tone % tones.length];
            ctx.lineWidth = s.width * (0.68 + intensity * 0.34);
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + s.len, y - s.amp * 0.2);
            ctx.stroke();
          }
          ctx.restore();
        }

        if (feverFx.flash > 0.001) {
          ctx.save();
          ctx.globalAlpha = feverFx.flash * (reducedMotionQuery.matches ? 0.14 : 0.26);
          ctx.fillStyle = '#ddf5ff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.restore();
        }
      }

      function drawFeverShockwavesLayer() {
        if (!feverShockwaves.length) return;
        const density = getRuntimeFxDensity();
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (const w of feverShockwaves) {
          if (w.t < 0) continue;
          const p = clamp(w.t / w.life, 0, 1);
          const k = w.mode === 'collapse' ? easeInCubic(p) : easeOutCubic(p);
          const radius = w.startR + (w.endR - w.startR) * k;
          const alpha = (1 - p) * (w.mode === 'collapse' ? 0.46 : 0.58) * (0.45 + density * 0.55);
          if (alpha <= 0.01) continue;
          ctx.globalAlpha = alpha;
          ctx.strokeStyle = `rgba(${w.color}, 1)`;
          ctx.lineWidth = Math.max(1.4, w.width * (1 - p * 0.78));
          ctx.beginPath();
          ctx.arc(w.x, w.y, radius, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawFeverSparkLayer() {
        if (!feverSparks.length) return;
        const toneColor = ['#ffe18f', '#ff8cbf', '#8bc9ff'];
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (const s of feverSparks) {
          const lifeK = 1 - (s.t / s.life);
          if (lifeK <= 0) continue;
          const trail = s.mode === 'converge' ? 0.020 : 0.03;
          const px = s.x - s.vx * trail;
          const py = s.y - s.vy * trail;
          ctx.globalAlpha = lifeK * (s.mode === 'hit' ? 0.88 : 0.76);
          ctx.strokeStyle = toneColor[s.tone % toneColor.length];
          ctx.lineWidth = Math.max(1.1, s.size * lifeK);
          ctx.beginPath();
          ctx.moveTo(px, py);
          ctx.lineTo(s.x, s.y);
          ctx.stroke();
          if (s.mode === 'hit') {
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.size * lifeK * 0.75, 0, Math.PI * 2);
            ctx.fillStyle = toneColor[s.tone % toneColor.length];
            ctx.fill();
          }
        }
        ctx.restore();
      }

      function drawFeverHitBurstsLayer() {
        if (!feverHitBursts.length) return;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (const hb of feverHitBursts) {
          const p = clamp(hb.t / hb.life, 0, 1);
          const lifeK = 1 - p;
          if (lifeK <= 0) continue;
          const ringR = hb.r0 + (hb.r1 - hb.r0) * easeOutCubic(p);
          ctx.globalAlpha = lifeK * 0.66;
          ctx.strokeStyle = hb.color;
          ctx.lineWidth = Math.max(1.2, 7 * lifeK);
          ctx.beginPath();
          ctx.arc(hb.x, hb.y, ringR, 0, Math.PI * 2);
          ctx.stroke();

          const cross = 6 + ringR * 0.24;
          ctx.lineWidth = Math.max(1.0, 4 * lifeK);
          ctx.beginPath();
          ctx.moveTo(hb.x - cross, hb.y);
          ctx.lineTo(hb.x + cross, hb.y);
          ctx.moveTo(hb.x, hb.y - cross);
          ctx.lineTo(hb.x, hb.y + cross);
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawParallaxCloudLayer(now, dynamicFx, feverIntensity) {
        const cloudCount = Math.max(4, Math.round((6 + dynamicFx * 4) * (reducedMotionQuery.matches ? 0.7 : 1)));
        const tone = feverIntensity > 0.06 ? '#fff7eb' : '#ffffff';
        ctx.save();
        for (let i=0; i<cloudCount; i++) {
          const speed = 9 + i * 2.8;
          const travel = ((now * 0.010 * speed * backgroundMotionScale) + i * 230) % (canvas.width + 300);
          const x = travel - 150;
          const y = canvas.height * (0.09 + (i % 4) * 0.065) + Math.sin(now * 0.00045 + i) * 10;
          const w = 90 + (i % 3) * 28;
          const h = 30 + (i % 2) * 10;

          ctx.globalAlpha = (0.20 + (i % 3) * 0.06) * (0.7 + dynamicFx * 0.3);
          ctx.fillStyle = tone;
          ctx.beginPath();
          ctx.ellipse(x, y, w * 0.46, h * 0.5, 0, 0, Math.PI * 2);
          ctx.ellipse(x + w * 0.24, y - h * 0.16, w * 0.34, h * 0.42, 0, 0, Math.PI * 2);
          ctx.ellipse(x - w * 0.24, y - h * 0.10, w * 0.30, h * 0.38, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawTerrainLayer(baseY, amp, step, color, alpha, phase) {
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(0, canvas.height);
        for (let x=0; x<=canvas.width + step; x+=step) {
          const y = baseY + Math.sin(x * 0.006 + phase) * amp + Math.sin(x * 0.013 + phase * 1.2) * amp * 0.42;
          ctx.lineTo(x, y);
        }
        ctx.lineTo(canvas.width, canvas.height);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      function drawShootingStarsLayer() {
        if (!shootingStars.length) return;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (const s of shootingStars) {
          const lifeK = 1 - (s.t / s.life);
          if (lifeK <= 0) continue;
          const tx = s.x - s.vx * 0.05;
          const ty = s.y - s.vy * 0.05;
          const trail = ctx.createLinearGradient(s.x, s.y, tx, ty);
          trail.addColorStop(0, s.tone);
          trail.addColorStop(1, 'rgba(255,255,255,0)');
          ctx.globalAlpha = lifeK * 0.92;
          ctx.strokeStyle = trail;
          ctx.lineWidth = s.width * (0.7 + lifeK * 0.7);
          ctx.beginPath();
          ctx.moveTo(s.x, s.y);
          ctx.lineTo(tx, ty);
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawNightCityBackdrop(now, dynamicFx, intensity) {
        const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
        sky.addColorStop(0, '#081229');
        sky.addColorStop(0.48, '#112145');
        sky.addColorStop(1, '#1e2c4e');
        ctx.fillStyle = sky;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        const moon = ctx.createRadialGradient(
          canvas.width * 0.82,
          canvas.height * 0.15,
          10,
          canvas.width * 0.82,
          canvas.height * 0.15,
          canvas.width * 0.12
        );
        moon.addColorStop(0, 'rgba(255,255,238,0.92)');
        moon.addColorStop(0.46, 'rgba(193,225,255,0.45)');
        moon.addColorStop(1, 'rgba(155,194,255,0)');
        ctx.globalAlpha = 0.44 + intensity * 0.22;
        ctx.fillStyle = moon;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();

        const sparkleCount = Math.max(36, Math.round((70 + intensity * 90) * dynamicFx));
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (let i=0; i<sparkleCount; i++) {
          const x = (i * 137.17 + (i % 5) * 11.4) % canvas.width;
          const y = 18 + ((i * 71.31) % (canvas.height * 0.58));
          const twinkle = 0.35 + 0.65 * (0.5 + 0.5 * Math.sin(now * 0.002 + i * 1.17));
          const r = (i % 3 ? 1.0 : 1.7) * (0.8 + intensity * 0.3);
          ctx.globalAlpha = twinkle * (0.34 + intensity * 0.36);
          ctx.fillStyle = i % 4 === 0 ? '#ffd9aa' : i % 4 === 1 ? '#a9deff' : '#d1c2ff';
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();

        const horizon = canvas.height * 0.72;
        ctx.save();
        let x = -20;
        let i = 0;
        while (x < canvas.width + 30) {
          const bw = 44 + ((i * 37) % 56);
          const bh = canvas.height * (0.18 + ((i * 29) % 84) / 260 + intensity * 0.06);
          const y = horizon - bh;
          const tone = 20 + (i % 5) * 8;
          ctx.fillStyle = `rgb(${tone - 8}, ${tone + 6}, ${tone + 20})`;
          ctx.fillRect(x, y, bw, canvas.height - y);

          const winCols = Math.max(2, Math.floor(bw / 13));
          const winRows = Math.max(4, Math.floor((bh - 18) / 14));
          const offsetX = x + 4;
          const offsetY = y + 8;
          for (let cx=0; cx<winCols; cx++) {
            for (let cy=0; cy<winRows; cy++) {
              const light = Math.sin(now * 0.0024 + i * 0.62 + cx * 0.9 + cy * 1.2);
              if (light < 0.05) continue;
              const wx = offsetX + cx * ((bw - 8) / winCols);
              const wy = offsetY + cy * ((bh - 14) / winRows);
              ctx.globalAlpha = (0.25 + light * 0.22) * (0.68 + intensity * 0.32);
              ctx.fillStyle = (cx + cy + i) % 3 === 0 ? '#ffd58d' : (cx + i) % 2 === 0 ? '#b8e0ff' : '#f8f0ff';
              ctx.fillRect(wx, wy, 4, 6);
            }
          }
          x += bw - 3;
          i++;
        }
        ctx.restore();

        ctx.save();
        const groundGlow = ctx.createLinearGradient(0, horizon - 6, 0, canvas.height);
        groundGlow.addColorStop(0, 'rgba(88,123,190,0.16)');
        groundGlow.addColorStop(1, 'rgba(15,26,49,0.54)');
        ctx.fillStyle = groundGlow;
        ctx.fillRect(0, horizon - 4, canvas.width, canvas.height - horizon + 4);
        ctx.restore();

        drawShootingStarsLayer();
      }

      function drawBackground() {
        const now = performance.now();
        const dynamicFx = clamp(fxDensity * runtimeFxQuality, 0.18, 1.18);
        const feverState = getFeverVisualState(totalElapsed);
        const feverIntensity = feverState.intensity;
        const feverBoost = 1 + feverIntensity * (reducedMotionQuery.matches ? 0.18 : 0.34);
        const drift = now * 0.00024 * backgroundMotionScale * feverBoost;
        const nightBlend = clamp((feverIntensity - 0.08) / 0.38, 0, 1);

        if (nightBlend >= 0.4) {
          drawNightCityBackdrop(now, dynamicFx, clamp(0.66 + feverIntensity * 0.44, 0, 1.2));
          drawFeverBackdrop(now, feverState, dynamicFx);
          drawFeverShockwavesLayer();
          return;
        }

        const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
        sky.addColorStop(0, '#65c0ff');
        sky.addColorStop(0.5, '#a9ecff');
        sky.addColorStop(1, '#dbffc9');
        ctx.fillStyle = sky;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        const sun = ctx.createRadialGradient(
          canvas.width * 0.82,
          canvas.height * 0.12,
          10,
          canvas.width * 0.82,
          canvas.height * 0.12,
          canvas.width * 0.16
        );
        sun.addColorStop(0, 'rgba(255,255,245,0.95)');
        sun.addColorStop(0.45, 'rgba(255,240,174,0.55)');
        sun.addColorStop(1, 'rgba(255,220,131,0)');
        ctx.globalAlpha = 0.55 + feverIntensity * 0.15;
        ctx.fillStyle = sun;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();

        drawParallaxCloudLayer(now, dynamicFx, feverIntensity);
        drawFeverBackdrop(now, feverState, dynamicFx);

        drawTerrainLayer(
          canvas.height * (0.72 - feverIntensity * 0.02),
          24 + feverIntensity * 8,
          72,
          '#9fdfa3',
          0.62,
          drift * 0.84
        );

        drawTerrainLayer(
          canvas.height * (0.82 - feverIntensity * 0.012),
          18 + feverIntensity * 7,
          64,
          '#7fce7e',
          0.74,
          drift * 1.06 + 1.2
        );

        drawTerrainLayer(
          canvas.height * (0.90 - feverIntensity * 0.006),
          14 + feverIntensity * 5,
          56,
          '#63b95b',
          0.92,
          drift * 1.3 + 2.2
        );

        const moteCount = Math.max(6, Math.round((14 + feverIntensity * 12) * dynamicFx));
        ctx.save();
        ctx.globalAlpha = (0.18 + feverIntensity * 0.12) * (0.46 + dynamicFx * 0.54);
        for (let i=0; i<moteCount; i++) {
          const speed = (0.04 + feverIntensity * 0.04) * backgroundMotionScale;
          const x = (i * 137 + (now * speed)) % canvas.width;
          const y = 84 + (i * 49) % Math.max(180, Math.round(330 * (0.62 + dynamicFx * 0.38)));
          ctx.beginPath();
          ctx.arc(x, y, (2 + (i % 3)) * (0.75 + dynamicFx * 0.25), 0, Math.PI*2);
          ctx.fillStyle = ['#ff8eb9','#ffe18f','#8bd7ff','#b8ff9b','#ffffff'][i % 5];
          ctx.fill();
        }
        ctx.restore();

        drawFeverShockwavesLayer();
      }

      function drawBasket() {
        const x = basket.x;
        const y = basket.y;
        const w = basket.w;
        const h = basket.h;

        ctx.save();
        ctx.translate(x, y);
        ctx.scale(1, drawFixScaleY);

        ctx.globalAlpha = 0.22;
        ctx.fillStyle = '#2b4a69';
        ctx.beginPath();
        ctx.ellipse(0, h * 0.48, w * 0.42, h * 0.18, 0, 0, Math.PI * 2);
        ctx.fill();

        const shell = ctx.createLinearGradient(0, -h * 0.5, 0, h * 0.5);
        shell.addColorStop(0, '#ffe6b2');
        shell.addColorStop(0.62, '#f6bd67');
        shell.addColorStop(1, '#dc9846');
        ctx.fillStyle = shell;
        roundedRect(-w/2, -h/2, w, h, 20);
        ctx.fill();

        ctx.save();
        roundedRect(-w/2 + 8, -h/2 + 8, w - 16, h - 16, 14);
        ctx.clip();

        ctx.globalAlpha = 0.32;
        ctx.strokeStyle = '#d38337';
        ctx.lineWidth = Math.max(2, h * 0.085);
        for (let ix = -w; ix <= w; ix += 20) {
          ctx.beginPath();
          ctx.moveTo(ix, -h);
          ctx.lineTo(ix + w, h);
          ctx.stroke();
        }

        ctx.globalAlpha = 0.22;
        for (let ix = -w; ix <= w; ix += 22) {
          ctx.beginPath();
          ctx.moveTo(ix, h);
          ctx.lineTo(ix + w, -h);
          ctx.stroke();
        }
        ctx.restore();

        ctx.fillStyle = 'rgba(255,242,213,.9)';
        roundedRect(-w/2 + 8, -h/2 + 8, w - 16, h * 0.2, 10);
        ctx.fill();

        ctx.strokeStyle = '#fbe8c1';
        ctx.lineWidth = Math.max(3, h * 0.09);
        ctx.beginPath();
        ctx.arc(0, -h/2 + 6, w*0.29, Math.PI * 1.05, Math.PI * 1.95, true);
        ctx.stroke();

        ctx.strokeStyle = '#b36d33';
        ctx.lineWidth = Math.max(2, h * 0.05);
        ctx.beginPath();
        ctx.arc(0, -h/2 + 6, w*0.29, Math.PI * 1.05, Math.PI * 1.95, true);
        ctx.stroke();

        ctx.restore();
      }

      function drawObject(o) {
        ctx.save();
        ctx.translate(o.x, o.y);
        ctx.scale(1, drawFixScaleY);
        ctx.rotate(o.rot);

        if (o.kind === 'star') {
          const glow = ctx.createRadialGradient(0, 0, o.r * 0.08, 0, 0, o.r * 1.45);
          glow.addColorStop(0, 'rgba(255,250,211,.9)');
          glow.addColorStop(0.38, 'rgba(255,223,128,.65)');
          glow.addColorStop(1, 'rgba(255,183,92,0)');
          ctx.fillStyle = glow;
          ctx.beginPath();
          ctx.arc(0, 0, o.r * 1.45, 0, Math.PI * 2);
          ctx.fill();

          const starFill = ctx.createLinearGradient(-o.r, -o.r, o.r, o.r);
          starFill.addColorStop(0, '#fff7b6');
          starFill.addColorStop(0.56, '#ffd86a');
          starFill.addColorStop(1, '#ffb95b');
          ctx.fillStyle = starFill;
          drawStarPath(o.r, o.r * 0.5);
          ctx.fill();

          ctx.lineWidth = Math.max(1.5, o.r * 0.09);
          ctx.strokeStyle = 'rgba(255,255,255,.65)';
          ctx.stroke();

          ctx.fillStyle = 'rgba(255,255,255,.6)';
          drawStarPath(o.r * 0.42, o.r * 0.2);
          ctx.fill();

          ctx.restore();
          return;
        }

        const style = getFruitStyle(o.fruitKind);
        if (style.kind === 'banana') {
          drawBanana(style, o.r);
        } else if (style.kind === 'apple') {
          drawApple(style, o.r);
        } else if (style.kind === 'orange') {
          drawOrange(style, o.r);
        } else if (style.kind === 'peach') {
          drawPeach(style, o.r);
        } else if (style.kind === 'strawberry') {
          drawStrawberry(style, o.r);
        } else if (style.kind === 'grape') {
          drawGrape(style, o.r);
        } else if (style.kind === 'watermelon') {
          drawWatermelon(style, o.r);
        } else {
          drawRoundFruit(style, o.r);
        }

        ctx.restore();
      }

      function drawParticles(dt) {
        for (let i=pops.length-1;i>=0;i--){
          const p = pops[i];
          p.t += dt;
          const k = 1 - (p.t / p.life);
          if (k <= 0) { pops.splice(i,1); continue; }
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vy += 980 * dt;

          const alpha = Math.max(0, k) * particleDensity;
          if (alpha <= 0.01) continue;
          const size = p.r * (0.5 + k * (0.5 + particleDensity * 0.2));

          ctx.globalAlpha = alpha * (fever ? 1.0 : 0.9);
          ctx.fillStyle = p.color;
          ctx.beginPath();
          if ((i % 4) === 0) {
            ctx.moveTo(p.x, p.y - size);
            ctx.lineTo(p.x + size * 0.76, p.y);
            ctx.lineTo(p.x, p.y + size);
            ctx.lineTo(p.x - size * 0.76, p.y);
            ctx.closePath();
          } else {
            ctx.arc(p.x, p.y, size, 0, Math.PI*2);
          }
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }

      function drawFloatTexts(dt) {
        for (let i=floatTexts.length-1;i>=0;i--){
          const ft = floatTexts[i];
          ft.t += dt;
          const k = 1 - (ft.t / ft.life);
          if (k <= 0) { floatTexts.splice(i,1); continue; }
          ft.y += ft.vy * dt;

          ctx.save();
          ctx.globalAlpha = Math.max(0, k);
          ctx.translate(ft.x, ft.y);
          ctx.scale(1, drawFixScaleY);
          const fontSize = Math.max(20, Math.round(30 * floatTextScale));
          ctx.font = `900 ${fontSize}px "M PLUS Rounded 1c",sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          ctx.strokeStyle = 'rgba(32,48,73,.42)';
          ctx.lineWidth = Math.max(4, fontSize * 0.22);
          ctx.strokeText(ft.text, 0, 0);

          const textFill = ctx.createLinearGradient(-fontSize * 0.8, 0, fontSize * 0.8, 0);
          textFill.addColorStop(0, '#fffdf4');
          textFill.addColorStop(0.5, ft.color);
          textFill.addColorStop(1, '#fffdf4');
          ctx.fillStyle = textFill;
          ctx.fillText(ft.text, 0, 0);
          ctx.restore();
        }
      }

      // Main loop
      let last = performance.now();
      function frame(now) {
        const dt = Math.min(0.033, (now - last) / 1000);
        last = now;

        // Clear
        ctx.clearRect(0,0,canvas.width,canvas.height);
        updateDrawFixScale();

        // Background
        drawBackground();

        if (running && !paused) {
          totalElapsed += dt;
          updateFeverEffects(dt);

          // speed multiplier (every 30 sec +10%)
          const gMul = globalSpeedMultiplier();

          // Basket movement
          const left = keys.has('ArrowLeft') || keys.has('a') || keys.has('A');
          const right = keys.has('ArrowRight') || keys.has('d') || keys.has('D');

          if (left) basket.vx = -basket.speed;
          else if (right) basket.vx = basket.speed;
          else basket.vx *= 0.85;

          // Mouse target easing
          if (basket.targetX != null) {
            const dx = basket.targetX - basket.x;
            basket.x += dx * (1 - Math.pow(0.000001, dt));
          } else {
            basket.x += basket.vx * dt;
          }

          basket.x = clamp(basket.x, basket.w/2 + 14, canvas.width - basket.w/2 - 14);

          // Spawn
          spawnTimer += dt;
          if (spawnTimer >= spawnInterval()) {
            spawnTimer = 0;
            spawnObject();
          }

          // Fever timer UI & end
          if (fever) {
            const remain = Math.max(0, feverEnd - totalElapsed);
            feverTimeEl.textContent = `${remain.toFixed(1)}s`;
            if (remain <= 0) {
              fever = false;
              if (music && soundOn) music.setMode('normal');
              setFeverPhase('exit', totalElapsed);
              pop(canvas.width*0.5, canvas.height*0.22, '#ffffff', 24);
            }
          }

          // Update objects
          for (let i=objects.length-1;i>=0;i--){
            const o = objects[i];

            const vy = o.vyBase * o.baseMul * gMul;

            o.y += vy * dt;
            o.rot += o.spin * dt * rotationMotionScale;

            // Catch?
            if (intersectsObjBasket(o)) {
              objects.splice(i,1);

              if (o.kind === 'star') {
                // Fever start (20s), points x2
                fever = true;
                feverEnd = totalElapsed + FEVER_DURATION;
                setFeverPhase('enter', totalElapsed, o.x, o.y);

                pop(o.x, o.y, '#ffd670', 34);
                pop(o.x, o.y, '#ff70a6', 28);
                pop(o.x, o.y, '#9b5de5', 20);
                addFloatText(o.x, o.y - 10, 'フィーバー！', '#ffd670');
                triggerFeverHitFeedback(o.x, o.y, '#ffd670');

                sfx('star');
                if (music && soundOn) music.setMode('fever');
                continue;
              }

              const basePts = o.points;
              const got = fever ? basePts * 2 : basePts;

              score += got;
              scoreEl.textContent = String(score);

              pop(o.x, o.y, o.color, fever ? 30 : 14);
              const scoreText = fever ? `${basePts}×2 = +${got}` : `+${got}`;
              addFloatText(o.x, o.y - 12, scoreText, fever ? '#ffd670' : o.color);
              if (fever) triggerFeverHitFeedback(o.x, o.y, '#ffd670');
              sfx('catch');
              continue;
            }

            // Missed?
            if (o.y - o.r > canvas.height + 10) {
              objects.splice(i,1);

              if (o.kind === 'star') continue;

              misses++;
              updateHearts();
              pop(clamp(o.x, 40, canvas.width-40), canvas.height-55, '#ff4d6d', 14);
              sfx('miss');
              triggerLifeDamageEffect();

              if (misses >= MAX_MISSES) {
                endGame();
                break;
              }
            }
          }
        }

        // Draw objects
        for (const o of objects) drawObject(o);

        // Draw basket
        drawBasket();

        // Fever foreground FX
        drawFeverSparkLayer();
        drawFeverHitBurstsLayer();

        // Particles & float texts
        drawParticles(dt);
        drawFloatTexts(dt);

        if (damageFlash > 0.001) {
          const alpha = clamp(damageFlash, 0, 1) * (reducedMotionQuery.matches ? 0.14 : 0.2);
          ctx.save();
          ctx.fillStyle = `rgba(255,66,112,${alpha.toFixed(3)})`;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.restore();
        }
        damageFlash = Math.max(0, damageFlash - dt * (reducedMotionQuery.matches ? 1.9 : 2.7));

        requestAnimationFrame(frame);
      }

      // Init
      applyResponsiveProfile();
      window.addEventListener('resize', scheduleResponsiveProfileApply, {passive:true});
      window.addEventListener('orientationchange', scheduleResponsiveProfileApply, {passive:true});
      if (typeof reducedMotionQuery.addEventListener === 'function') {
        reducedMotionQuery.addEventListener('change', scheduleResponsiveProfileApply);
      } else if (typeof reducedMotionQuery.addListener === 'function') {
        reducedMotionQuery.addListener(scheduleResponsiveProfileApply);
      }
      if (typeof coarsePointerQuery.addEventListener === 'function') {
        coarsePointerQuery.addEventListener('change', scheduleResponsiveProfileApply);
      } else if (typeof coarsePointerQuery.addListener === 'function') {
        coarsePointerQuery.addListener(scheduleResponsiveProfileApply);
      }
      updateHearts();
      resetOverlayTextToStart();
      requestAnimationFrame(frame);

      // Start with overlay (music off until start)
      if (music) music.setEnabled(false);
    })();
  </script>
</body>
</html>
