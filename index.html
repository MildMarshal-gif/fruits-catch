<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>フルーツキャッチ</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@700;800;900&family=Zen+Maru+Gothic:wght@700;900&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg1:#7bdff2; /* sky */
      --bg2:#b2f7ef; /* mint */
      --bg3:#eff7f6; /* cloud */
      --accent:#ff70a6;
      --accent2:#ff9770;
      --accent3:#ffd670;
      --good:#46d19f;
      --bad:#ff4d6d;
      --ink:#1f2937;
      --card:#ffffffcc;
      --fever1:#ffd670;
      --fever2:#9b5de5;
      --fever3:#ff70a6;
      --ui-scale:1;
      --hud-scale:1;
      --title-scale:1;
      --fx-density:1;
      --fruit-scale:1;
      --basket-scale:1;
      --pause-scale:1;
      --motion-scale:1;
      --tap-target:40px;
      --hud-inset-top:14px;
      --hud-inset-side:14px;
      --text-leading:1.35;
      --fever-neon-a:#ffd670;
      --fever-neon-b:#ff70a6;
      --fever-neon-c:#9b5de5;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; }
    body{
      font-family: "M PLUS Rounded 1c","Zen Maru Gothic","Kosugi Maru","Hiragino Maru Gothic ProN",
                   "Yu Gothic UI","Meiryo",system-ui,sans-serif;
      display:grid;
      place-items:center;
      overflow:hidden;
      background:
        radial-gradient(1200px 700px at 20% 10%, var(--bg3) 0 25%, transparent 26%),
        radial-gradient(900px 600px at 80% 20%, var(--bg3) 0 22%, transparent 23%),
        radial-gradient(800px 500px at 50% 0%, #ffffffaa 0 18%, transparent 19%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
    }

    .wrap{
      width:min(980px, 96vw);
      aspect-ratio: 16 / 9;
      position:relative;
      border-radius:24px;
      box-shadow: 0 18px 55px rgba(0,0,0,.18);
      overflow:hidden;
      background: linear-gradient(180deg, rgba(255,255,255,.20), rgba(255,255,255,.05));
      backdrop-filter: blur(8px);
    }

    canvas{ width:100%; height:100%; display:block; }

    .hud{
      position:absolute;
      inset:
        calc(var(--hud-inset-top) + env(safe-area-inset-top))
        var(--hud-inset-side)
        auto
        var(--hud-inset-side);
      display:grid;
      grid-template-columns:minmax(0, 1fr) auto;
      grid-template-areas:
        "pill btns"
        "pill badge";
      column-gap: calc(12px * var(--hud-scale));
      row-gap: calc(8px * var(--hud-scale));
      align-items:start;
      pointer-events:none;
    }

    .pill{
      background: var(--card);
      color:var(--ink);
      border: 2px solid rgba(255,255,255,.65);
      border-radius:999px;
      padding: calc(10px * var(--hud-scale)) calc(14px * var(--hud-scale));
      display:flex;
      gap: calc(12px * var(--hud-scale));
      align-items:center;
      flex-wrap:wrap;
      min-width:0;
      max-width:100%;
      font-weight:900;
      font-size: calc(14px * var(--hud-scale));
      line-height:1.2;
      letter-spacing:.2px;
      box-shadow: 0 10px 22px rgba(0,0,0,.12);
      pointer-events:none;
      grid-area:pill;
    }

    .pill .big{ font-size: calc(18px * var(--hud-scale)); }
    .mini{ font-size: calc(14px * var(--hud-scale)); opacity:.85; font-weight:900; }
    #score{
      display:inline-block;
      min-width:2ch;
      transform-origin:center;
      transition: transform .09s linear, text-shadow .09s linear, color .16s ease;
    }

    .hearts{
      display:flex;
      gap: calc(6px * var(--hud-scale));
      align-items:center;
      min-width: fit-content;
    }
    .life-heart{
      width: calc(21px * var(--hud-scale));
      height: calc(21px * var(--hud-scale));
      border-radius: 8px;
      border: 2px solid #e11d48;
      background: #ffe4ec;
      color: #b1133f;
      display:grid;
      place-items:center;
      font-size: calc(13px * var(--hud-scale));
      line-height:1;
      font-weight:1000;
    }
    .life-heart.off{
      border-color: #94a3b8;
      background: #e2e8f0;
      color: #64748b;
    }

    .btns{
      display:flex;
      gap: calc(10px * var(--hud-scale));
      flex-wrap:wrap;
      justify-content:flex-end;
      pointer-events:auto;
      grid-area:btns;
    }
    button{
      cursor:pointer;
      border:none;
      border-radius:999px;
      min-height: var(--tap-target);
      min-width: var(--tap-target);
      padding: calc(10px * var(--hud-scale)) calc(14px * var(--hud-scale));
      font-weight:900;
      font-size: calc(14px * var(--ui-scale));
      line-height:1.15;
      color:#102a43;
      background:#ffffff;
      box-shadow: 0 10px 22px rgba(0,0,0,.12);
      border:2px solid rgba(255,255,255,.65);
      transition: transform .08s ease, box-shadow .15s ease;
      font-family: inherit;
      touch-action: manipulation;
    }
    button:hover{ transform: translateY(-1px); box-shadow: 0 14px 28px rgba(0,0,0,.16); }
    button:active{ transform: translateY(1px); }
    button:focus-visible{
      outline: 3px solid rgba(16,42,67,.7);
      outline-offset: 2px;
    }

    .badge{
      background: rgba(255,255,255,.92);
      border:2px solid rgba(255,255,255,.75);
      box-shadow: 0 10px 22px rgba(0,0,0,.12);
      border-radius: 16px;
      padding: calc(10px * var(--hud-scale)) calc(12px * var(--hud-scale));
      font-weight:1000;
      font-size: calc(14px * var(--hud-scale));
      line-height:1.2;
      color:var(--ink);
      display:none;
      max-width:min(74vw, 360px);
      width: fit-content;
      margin-top: calc(2px * var(--hud-scale));
      justify-self:end;
      align-self:start;
      grid-area:badge;
      pointer-events:none;
    }
    .badge.show{ display:block; }
    .badge .line{ display:flex; align-items:center; gap:10px; }
    .badge .spark{
      font-size: calc(18px * var(--hud-scale));
      filter: drop-shadow(0 2px 2px rgba(0,0,0,.12));
    }
    .badge.fever-neon{
      color:#fffaf0;
      background:
        linear-gradient(120deg, var(--fever-neon-b), var(--fever-neon-c), var(--fever-neon-a));
      border-color: rgba(255,255,255,.74);
      box-shadow:
        0 0 0 1px rgba(255,255,255,.35) inset,
        0 0 14px rgba(255,112,166,.55),
        0 0 24px rgba(155,93,229,.46),
        0 14px 28px rgba(0,0,0,.2);
      animation: badgeNeonPulse 1.2s ease-in-out infinite;
      backdrop-filter: blur(3px);
    }
    .badge.fever-neon .spark{
      filter: drop-shadow(0 0 6px rgba(255,214,112,.75));
      animation: badgeSparkTwinkle .75s ease-in-out infinite alternate;
    }
    .badge.fever-neon #feverTime{
      color:#ffffff;
      text-shadow:
        0 0 6px rgba(255,255,255,.8),
        0 0 14px rgba(255,112,166,.58);
    }
    .badge.fever-neon[data-phase="enter"]{
      animation-duration:0.85s;
    }
    .badge.fever-neon[data-phase="active"]{
      animation-duration:1.08s;
    }
    .badge.fever-neon[data-phase="exit"]{
      animation-duration:1.36s;
      opacity:.9;
    }

    @keyframes badgeNeonPulse{
      0%,100%{
        transform: scale(1);
        filter: saturate(1);
      }
      50%{
        transform: scale(1.035);
        filter: saturate(1.18);
      }
    }
    @keyframes badgeSparkTwinkle{
      from{ transform: translateY(0); }
      to{ transform: translateY(-1px) scale(1.08); }
    }

    .overlay{
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      background: linear-gradient(180deg, rgba(0,0,0,.10), rgba(0,0,0,.22));
      backdrop-filter: blur(6px);
      opacity:0;
      pointer-events:none;
      transition: opacity .25s ease;
    }
    .overlay.show{ opacity:1; pointer-events:auto; }

    .card{
      width:min(540px, 92%);
      border-radius:26px;
      padding:
        calc(22px * var(--ui-scale))
        calc(22px * var(--ui-scale))
        calc(18px * var(--ui-scale));
      background: rgba(255,255,255,.92);
      box-shadow: 0 18px 55px rgba(0,0,0,.2);
      border: 2px solid rgba(255,255,255,.75);
      text-align:center;
      color:var(--ink);
      line-height: var(--text-leading);
    }
    .title{
      font-size: calc(34px * var(--title-scale));
      line-height:1.15;
      font-weight:1000;
      margin:0 0 calc(10px * var(--ui-scale));
      letter-spacing:.3px;
    }
    .subtitle{
      margin:0 0 calc(14px * var(--ui-scale));
      font-size: calc(16px * var(--ui-scale));
      line-height:1.4;
      font-weight:900;
      opacity:.92;
    }
    .how{
      margin:0 0 calc(18px * var(--ui-scale));
      padding: calc(14px * var(--ui-scale)) calc(16px * var(--ui-scale));
      border-radius:18px;
      background: linear-gradient(90deg, rgba(255,112,166,.18), rgba(255,214,112,.22), rgba(70,209,159,.18));
      border: 2px dashed rgba(31,41,55,.18);
      font-size: calc(15px * var(--ui-scale));
      font-weight:900;
      line-height:1.45;
    }
    .stack{
      display:flex;
      gap: calc(10px * var(--ui-scale));
      justify-content:center;
      flex-wrap:wrap;
      margin-top: calc(6px * var(--ui-scale));
    }
    .note{
      font-size: calc(12px * var(--ui-scale));
      opacity:.75;
      font-weight:900;
      margin-top: calc(10px * var(--ui-scale));
      line-height:1.4;
    }

    :root[data-device="mobile"] .hud{
      grid-template-columns:1fr;
      grid-template-areas:
        "pill"
        "btns"
        "badge";
    }

    :root[data-device="mobile"] .pill{
      width:100%;
    }

    :root[data-device="mobile"] .btns{
      width:100%;
      justify-content:space-between;
    }

    :root[data-device="mobile"] .badge{
      justify-self:start;
      max-width:100%;
    }

    /* Responsive tweaks */
    @media (max-width: 680px) {
      body{
        place-items: stretch;
      }

      .wrap{
        width: 100vw;
        height: 100dvh;        /* iPhone address bar safe */
        aspect-ratio: auto;
        border-radius: 0;
      }

      canvas{
        width: 100%;
        height: 100%;
      }

      .card{
        width: min(560px, 94vw);
        max-height: calc(100dvh - 28px - env(safe-area-inset-top) - env(safe-area-inset-bottom));
        overflow: auto;
        -webkit-overflow-scrolling: touch;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      .overlay,
      button{
        transition:none;
      }
      #score{
        transition: color .16s ease;
      }
      .badge.fever-neon,
      .badge.fever-neon .spark{
        animation:none;
      }
    }
  </style>
</head>

<body>
  <div class="wrap" aria-label="フルーツキャッチゲーム">
    <canvas id="game" width="1280" height="720"></canvas>

    <div class="hud">
      <div class="pill">
        <span class="big">スコア:</span>
        <span id="score" class="big">0</span>
        <span style="opacity:.55;">|</span>
        <span class="big">ミス:</span>
        <span class="hearts" id="hearts"></span>
        <span style="opacity:.55;">|</span>
        <span class="mini">スピード:</span>
        <span id="speedMul" class="mini">x1.00</span>
      </div>

      <div class="btns">
        <button id="restartBtn" type="button">リスタート</button>
        <button id="pauseBtn" type="button">一時停止</button>
      </div>

      <div class="badge" id="feverBadge" aria-live="polite">
        <div class="line">
          <span class="spark">✨</span>
          <span>フィーバー</span>
          <span id="feverTime" style="font-weight:1000;">20.0s</span>
          <span style="opacity:.7;">残り</span>
        </div>
      </div>
    </div>

    <div class="overlay show" id="overlay">
      <div class="card">
        <h1 class="title">🍓 フルーツキャッチ</h1>
        <p class="subtitle">カゴを動かして、フルーツをキャッチしよう！</p>
        <div class="how">
          ← / → か A / D で移動<br/>
          マウスやタッチでも移動OK<br/>
          3回ミスでゲームオーバー<br/>
          ⭐を取るとフィーバー（得点2倍）
        </div>
        <div class="stack">
          <button id="startBtn" type="button"
            style="background:linear-gradient(90deg,var(--accent),var(--accent3)); color:#1f2937;">
            スタート！
          </button>
          <button id="soundBtn" type="button">サウンド: オン</button>
        </div>
        <div class="note">スペースキーでも一時停止できます</div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      // UI
      const scoreEl = document.getElementById('score');
      const heartsEl = document.getElementById('hearts');
      const overlay = document.getElementById('overlay');
      const startBtn = document.getElementById('startBtn');
      const restartBtn = document.getElementById('restartBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const soundBtn = document.getElementById('soundBtn');
      const speedMulEl = document.getElementById('speedMul');
      const feverBadge = document.getElementById('feverBadge');
      const feverTimeEl = document.getElementById('feverTime');
      const root = document.documentElement;
      const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
      const coarsePointerQuery = window.matchMedia('(pointer:coarse)');

      const DEVICE_PRESETS = {
        mobile: {
          uiScale: 0.86,
          hudScale: 0.83,
          titleScale: 0.84,
          fxDensity: 0.56,
          fruitScale: 0.90,
          basketScale: 0.92,
          pauseScale: 0.78,
          tapTarget: 44
        },
        tablet: {
          uiScale: 0.95,
          hudScale: 0.91,
          titleScale: 0.93,
          fxDensity: 0.78,
          fruitScale: 0.95,
          basketScale: 0.96,
          pauseScale: 0.90,
          tapTarget: 42
        },
        desktop: {
          uiScale: 1.0,
          hudScale: 1.0,
          titleScale: 1.0,
          fxDensity: 1.0,
          fruitScale: 1.0,
          basketScale: 1.0,
          pauseScale: 1.0,
          tapTarget: 40
        }
      };

      const BASE_BASKET_W = 240;
      const BASE_BASKET_H = 62;
      const BASE_CANVAS_W = 1280;
      const BASE_CANVAS_H = 720;
      const BASE_FRUIT_RADIUS_MIN = 28;
      const BASE_FRUIT_RADIUS_MAX = 42;
      let fruitRadiusMin = BASE_FRUIT_RADIUS_MIN;
      let fruitRadiusMax = BASE_FRUIT_RADIUS_MAX;
      let fxDensity = 1;
      let particleDensity = 1;
      let backgroundMotionScale = 1;
      let rotationMotionScale = 1;
      let pausePanelScale = 1;
      let floatTextScale = 1;
      let drawFixScaleY = 1;

      // Game constants
      const MAX_MISSES = 3;

      // Basket (kid-friendly big)
      const basket = {
        w: BASE_BASKET_W,
        h: BASE_BASKET_H,
        x: BASE_CANVAS_W / 2,
        y: BASE_CANVAS_H - 90,
        vx: 0,
        speed: 1150, // px/s
        targetX: null
      };

      // Fruits with fixed speed multipliers (0.8-1.3) and points
      const FRUITS = [
        { emoji:'🍌', mul:0.80, points: 8,  color:'#ffd670' },
        { emoji:'🍏', mul:0.88, points: 9,  color:'#7ae582' },
        { emoji:'🍎', mul:0.95, points:10,  color:'#ff4d6d' },
        { emoji:'🍑', mul:1.02, points:10,  color:'#ff9770' },
        { emoji:'🍓', mul:1.10, points:11,  color:'#ff70a6' },
        { emoji:'🍇', mul:1.20, points:12,  color:'#9b5de5' },
        { emoji:'🍉', mul:1.30, points:13,  color:'#46d19f' },
      ];

      // Special star
      const STAR = { emoji:'⭐', chance:0.01 };

      // Spawn rate & base fall speed (global progression will multiply)
      function spawnInterval() {
        // start ~0.85s -> later ~0.55s
        const t = Math.min(1, totalElapsed / 120);
        return 0.85 - t * 0.30;
      }
      function baseFallSpeed() {
        return 310; // base speed before multipliers
      }

      // State
      let running = false;
      let paused = false;
      let gameOver = false;
      let score = 0;
      let misses = 0;

      // elapsed time for progression
      let totalElapsed = 0; // seconds

      // Fever
      let fever = false;
      let feverEnd = 0; // seconds (game time)
      const FEVER_DURATION = 20;
      const FEVER_ENTER_DURATION = 0.82;
      const FEVER_EXIT_DURATION = 0.56;

      const feverFx = {
        phase: 'idle', // idle | enter | active | exit
        phaseStart: 0,
        enterDuration: FEVER_ENTER_DURATION,
        exitDuration: FEVER_EXIT_DURATION,
        flash: 0,
        hitPulse: 0,
        originX: BASE_CANVAS_W * 0.5,
        originY: BASE_CANVAS_H * 0.35
      };
      let scorePulse = 0;
      let runtimeFxQuality = 1;

      // Entities
      const objects = []; // fruits & star
      const pops = [];
      const floatTexts = [];
      const feverShockwaves = [];
      const feverSparks = [];
      const feverHitBursts = [];
      const feverStreams = [];

      // Input
      const keys = new Set();
      window.addEventListener('keydown', (e) => {
        if (['ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
        keys.add(e.key);
        if (e.key === ' ' && running && !gameOver) togglePause();
      });
      window.addEventListener('keyup', (e) => keys.delete(e.key));

      function setBasketByClientX(clientX) {
        const rect = canvas.getBoundingClientRect();
        const x = (clientX - rect.left) / rect.width * canvas.width;
        basket.targetX = clamp(x, basket.w/2 + 14, canvas.width - basket.w/2 - 14);
      }
      canvas.addEventListener('mousemove', (e) => setBasketByClientX(e.clientX));
      canvas.addEventListener('touchstart', (e) => {
        if (e.touches?.[0]) setBasketByClientX(e.touches[0].clientX);
      }, {passive:true});
      canvas.addEventListener('touchmove', (e) => {
        if (e.touches?.[0]) setBasketByClientX(e.touches[0].clientX);
      }, {passive:true});

      // Buttons
      startBtn.addEventListener('click', () => startGame());
      restartBtn.addEventListener('click', () => restartGame());
      pauseBtn.addEventListener('click', () => togglePause());

      // Audio (WebAudio synth BGM: normal & fever)
      const audioCtx = (() => {
        try { return new (window.AudioContext || window.webkitAudioContext)(); }
        catch { return null; }
      })();
      let soundOn = true;

      soundBtn.textContent = `サウンド: ${soundOn ? 'オン' : 'オフ'}`;

      soundBtn.addEventListener('click', async () => {
        soundOn = !soundOn;
        soundBtn.textContent = `サウンド: ${soundOn ? 'オン' : 'オフ'}`;
        if (audioCtx && soundOn) {
          try { await audioCtx.resume(); } catch {}
        }
        setMusicEnabled(soundOn);
      });

      // SFX
      function sfx(type='catch') {
        if (!audioCtx || !soundOn) return;
        const t0 = audioCtx.currentTime;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.connect(g); g.connect(audioCtx.destination);

        let f1=700, f2=1000, dur=0.12;
        if (type==='miss'){ f1=240; f2=140; dur=0.14; }
        if (type==='star'){ f1=880; f2=1760; dur=0.18; }

        o.type = 'sine';
        o.frequency.setValueAtTime(f1, t0);
        o.frequency.exponentialRampToValueAtTime(f2, t0 + dur*0.6);

        g.gain.setValueAtTime(0.0001, t0);
        g.gain.exponentialRampToValueAtTime(0.20, t0 + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

        o.start(t0);
        o.stop(t0 + dur + 0.02);
      }

      // BGM sequencer
      const music = (() => {
        if (!audioCtx) return null;

        const master = audioCtx.createGain();
        master.gain.value = 0.22;
        master.connect(audioCtx.destination);

        const normalGain = audioCtx.createGain();
        const feverGain  = audioCtx.createGain();
        normalGain.gain.value = 0.0;
        feverGain.gain.value  = 0.0;
        normalGain.connect(master);
        feverGain.connect(master);

        let enabled = true;
        let mode = 'normal'; // 'normal' | 'fever'

        const lookAhead = 0.12;
        const interval = 25; // ms
        let timer = null;
        let nextNoteTime = 0;

        // cute chord-ish notes (freq)
        const N = {
          C4:261.63, D4:293.66, E4:329.63, F4:349.23, G4:392.00, A4:440.00, B4:493.88,
          C5:523.25, D5:587.33, E5:659.25, G5:783.99, A5:880.00
        };

        // Step patterns (16 steps)
        const normalMelody = [N.E5,0,N.G5,0, N.A5,0,N.G5,0, N.E5,0,N.D5,0, N.C5,0,N.D5,0];
        const normalBass   = [N.C4,0,N.C4,0, N.A4,0,N.A4,0, N.F4,0,N.F4,0, N.G4,0,N.G4,0];

        const feverMelody  = [N.A5,N.G5,N.E5,0, N.G5,N.E5,N.D5,0, N.E5,N.G5,N.A5,0, N.G5,N.E5,N.D5,0];
        const feverBass    = [N.A4,0,N.A4,0, N.G4,0,N.G4,0, N.E4,0,N.E4,0, N.D4,0,N.D4,0];

        const bpmNormal = 118;
        const bpmFever  = 140;

        function playNote(time, freq, duration, gainNode, type='triangle') {
          if (!freq) return;
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.type = type;
          o.frequency.setValueAtTime(freq, time);

          g.gain.setValueAtTime(0.0001, time);
          g.gain.exponentialRampToValueAtTime(0.18, time + 0.01);
          g.gain.exponentialRampToValueAtTime(0.0001, time + duration);

          o.connect(g);
          g.connect(gainNode);
          o.start(time);
          o.stop(time + duration + 0.01);
        }

        let step = 0;

        function scheduler() {
          if (!enabled) return;

          const now = audioCtx.currentTime;
          while (nextNoteTime < now + lookAhead) {
            const isFever = (mode === 'fever');
            const bpm = isFever ? bpmFever : bpmNormal;
            const secPerBeat = 60 / bpm;
            const stepDur = secPerBeat / 4; // 16th note

            const mel = isFever ? feverMelody : normalMelody;
            const bas = isFever ? feverBass   : normalBass;

            // melody
            playNote(nextNoteTime, mel[step % 16], stepDur*0.92, isFever ? feverGain : normalGain, 'triangle');
            // bass
            playNote(nextNoteTime, bas[step % 16], stepDur*0.98, isFever ? feverGain : normalGain, 'sine');

            // tiny hi-hat tick
            if ((step % 2) === 0) {
              const o = audioCtx.createOscillator();
              const g = audioCtx.createGain();
              o.type = 'square';
              o.frequency.setValueAtTime(isFever ? 2200 : 1800, nextNoteTime);
              g.gain.setValueAtTime(0.0001, nextNoteTime);
              g.gain.exponentialRampToValueAtTime(isFever ? 0.06 : 0.05, nextNoteTime + 0.005);
              g.gain.exponentialRampToValueAtTime(0.0001, nextNoteTime + 0.03);
              o.connect(g); g.connect(isFever ? feverGain : normalGain);
              o.start(nextNoteTime);
              o.stop(nextNoteTime + 0.04);
            }

            nextNoteTime += stepDur;
            step++;
          }
        }

        function start() {
          if (timer) return;
          nextNoteTime = audioCtx.currentTime + 0.05;
          timer = setInterval(scheduler, interval);
        }

        function stop() {
          if (!timer) return;
          clearInterval(timer);
          timer = null;
          normalGain.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.03);
          feverGain.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.03);
        }

        function setEnabled(v) {
          enabled = v;
          if (!enabled) stop();
          else start();
        }

        function setMode(newMode) {
          mode = newMode;
          const t = audioCtx.currentTime;
          if (mode === 'fever') {
            normalGain.gain.setTargetAtTime(0.0, t, 0.06);
            feverGain.gain.setTargetAtTime(1.0, t, 0.06);
          } else {
            feverGain.gain.setTargetAtTime(0.0, t, 0.06);
            normalGain.gain.setTargetAtTime(1.0, t, 0.06);
          }
        }

        return { start, stop, setEnabled, setMode };
      })();

      function setMusicEnabled(on) {
        if (!music) return;
        if (!on) music.setEnabled(false);
        else {
          music.setEnabled(true);
          music.setMode(fever ? 'fever' : 'normal');
        }
      }

      // Helpers
      function rand(a,b){ return a + Math.random()*(b-a); }
      function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
      function easeOutCubic(t){ const p = clamp(t, 0, 1); return 1 - Math.pow(1 - p, 3); }
      function easeInCubic(t){ const p = clamp(t, 0, 1); return p * p * p; }
      function getRuntimeFxDensity() {
        return clamp(particleDensity * runtimeFxQuality, 0.12, 1.12);
      }

      function updateScorePulseStyles() {
        const hot = fever || feverFx.phase !== 'idle';
        if (scorePulse <= 0.001) {
          scoreEl.style.transform = 'scale(1)';
          scoreEl.style.textShadow = 'none';
          scoreEl.style.color = '';
          return;
        }
        const pulseGain = reducedMotionQuery.matches ? 0.62 : 1.0;
        const scale = 1 + scorePulse * (hot ? 0.25 : 0.14) * pulseGain;
        const glow = Math.round((hot ? 10 : 6) + scorePulse * (hot ? 18 : 10) * pulseGain);
        scoreEl.style.transform = `scale(${scale.toFixed(3)})`;
        scoreEl.style.textShadow = hot
          ? `0 0 ${glow}px rgba(255,214,112,.9), 0 0 ${Math.round(glow * 1.6)}px rgba(255,112,166,.55)`
          : `0 0 ${glow}px rgba(255,255,255,.55)`;
        scoreEl.style.color = hot ? '#fffaf0' : '';
      }

      function clearFeverVisualState() {
        feverShockwaves.length = 0;
        feverSparks.length = 0;
        feverHitBursts.length = 0;
        feverFx.phase = 'idle';
        feverFx.phaseStart = 0;
        feverFx.flash = 0;
        feverFx.hitPulse = 0;
        scorePulse = 0;
        updateScorePulseStyles();
        feverBadge.dataset.phase = 'idle';
        feverBadge.classList.remove('fever-neon');
      }

      function rebuildFeverStreams() {
        feverStreams.length = 0;
        const density = getRuntimeFxDensity();
        const count = Math.max(6, Math.round((reducedMotionQuery.matches ? 8 : 16) * density));
        for (let i=0; i<count; i++) {
          feverStreams.push({
            lane: rand(0.16, 0.86),
            seed: Math.random() * 1000,
            speed: rand(0.58, 1.72),
            len: rand(72, 196),
            width: rand(1.5, 3.8),
            amp: rand(8, 26),
            tone: i % 3
          });
        }
      }

      function spawnFeverShockwave(x, y, type='entry') {
        if (type === 'entry') {
          const waveCount = Math.max(1, Math.round((reducedMotionQuery.matches ? 1 : 2) * getRuntimeFxDensity()));
          for (let i=0; i<waveCount; i++) {
            feverShockwaves.push({
              x, y,
              t: -i * 0.08,
              life: feverFx.enterDuration + 0.24 + i * 0.08,
              startR: 16 + i * 12,
              endR: Math.max(canvas.width, canvas.height) * (0.54 + i * 0.12),
              width: 22 - i * 6,
              color: i === 0 ? '255,255,255' : '255,214,112',
              mode: 'expand'
            });
          }
          return;
        }
        feverShockwaves.push({
          x, y,
          t: 0,
          life: feverFx.exitDuration + 0.18,
          startR: Math.max(canvas.width, canvas.height) * 0.50,
          endR: 24,
          width: 15,
          color: '255,255,255',
          mode: 'collapse'
        });
      }

      function spawnFeverEntrySparks(x, y) {
        const density = getRuntimeFxDensity();
        const count = Math.max(10, Math.round((reducedMotionQuery.matches ? 16 : 34) * density));
        for (let i=0; i<count; i++) {
          const angle = (Math.PI * 2 * i / count) + rand(-0.16, 0.16);
          const speed = rand(220, 720) * (0.52 + density * 0.48);
          feverSparks.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - rand(10, 70),
            t: 0,
            life: rand(0.36, 0.84),
            size: rand(2.2, 5.4),
            tone: i % 3,
            mode: 'burst'
          });
        }
      }

      function spawnFeverExitConverge() {
        const cx = canvas.width * 0.5;
        const cy = canvas.height * 0.36;
        const density = getRuntimeFxDensity();
        const count = Math.max(8, Math.round((reducedMotionQuery.matches ? 12 : 24) * density));
        for (let i=0; i<count; i++) {
          const edge = i % 4;
          let x = 0;
          let y = 0;
          if (edge === 0) { x = rand(0, canvas.width); y = -8; }
          if (edge === 1) { x = canvas.width + 8; y = rand(0, canvas.height); }
          if (edge === 2) { x = rand(0, canvas.width); y = canvas.height + 8; }
          if (edge === 3) { x = -8; y = rand(0, canvas.height); }
          const dx = cx - x;
          const dy = cy - y;
          const dist = Math.hypot(dx, dy) || 1;
          const speed = dist / rand(0.42, 0.76);
          feverSparks.push({
            x, y,
            vx: (dx / dist) * speed,
            vy: (dy / dist) * speed,
            t: 0,
            life: rand(0.46, 0.82),
            size: rand(1.8, 4.5),
            tone: i % 3,
            mode: 'converge'
          });
        }
      }

      function triggerFeverHitFeedback(x, y, color='#ffd670') {
        const density = getRuntimeFxDensity();
        const burstLife = reducedMotionQuery.matches ? 0.24 : 0.32;
        feverHitBursts.push({
          x, y,
          color,
          t: 0,
          life: burstLife,
          r0: 12,
          r1: 68
        });
        feverFx.hitPulse = clamp(feverFx.hitPulse + (reducedMotionQuery.matches ? 0.24 : 0.42), 0, 1.25);
        scorePulse = clamp(scorePulse + (fever ? 0.82 : 0.46), 0, 1.35);

        const sparkCount = Math.max(4, Math.round((reducedMotionQuery.matches ? 4 : 10) * density));
        for (let i=0; i<sparkCount; i++) {
          const angle = (Math.PI * 2 * i / sparkCount) + rand(-0.24, 0.24);
          const speed = rand(120, 360);
          feverSparks.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            t: 0,
            life: rand(0.16, 0.36),
            size: rand(1.4, 3.4),
            tone: i % 3,
            mode: 'hit'
          });
        }
      }

      function setFeverPhase(nextPhase, nowSec, originX = canvas.width * 0.5, originY = canvas.height * 0.35) {
        if (nextPhase === 'enter') {
          feverFx.phase = 'enter';
          feverFx.phaseStart = nowSec;
          feverFx.enterDuration = reducedMotionQuery.matches ? 0.64 : FEVER_ENTER_DURATION;
          feverFx.exitDuration = reducedMotionQuery.matches ? 0.44 : FEVER_EXIT_DURATION;
          feverFx.originX = originX;
          feverFx.originY = originY;
          feverFx.flash = reducedMotionQuery.matches ? 0.32 : 1.0;
          feverFx.hitPulse = reducedMotionQuery.matches ? 0.28 : 0.62;
          feverBadge.classList.add('show', 'fever-neon');
          feverBadge.dataset.phase = 'enter';
          spawnFeverShockwave(originX, originY, 'entry');
          spawnFeverEntrySparks(originX, originY);
          return;
        }
        if (nextPhase === 'active') {
          feverFx.phase = 'active';
          feverFx.phaseStart = nowSec;
          feverBadge.classList.add('show', 'fever-neon');
          feverBadge.dataset.phase = 'active';
          return;
        }
        if (nextPhase === 'exit') {
          feverFx.phase = 'exit';
          feverFx.phaseStart = nowSec;
          feverFx.flash = Math.max(feverFx.flash, reducedMotionQuery.matches ? 0.22 : 0.45);
          feverFx.hitPulse = Math.max(feverFx.hitPulse, reducedMotionQuery.matches ? 0.2 : 0.38);
          feverBadge.classList.add('show', 'fever-neon');
          feverBadge.dataset.phase = 'exit';
          spawnFeverShockwave(canvas.width * 0.5, canvas.height * 0.34, 'exit');
          spawnFeverExitConverge();
          return;
        }
        feverFx.phase = 'idle';
        feverFx.phaseStart = nowSec;
        feverFx.flash = 0;
        feverFx.hitPulse = 0;
        feverBadge.dataset.phase = 'idle';
        feverBadge.classList.remove('fever-neon');
        if (!fever) feverBadge.classList.remove('show');
      }

      function getFeverVisualState(nowSec) {
        if (feverFx.phase === 'idle') {
          return { phase:'idle', intensity:0, enterT:0, exitT:0 };
        }
        if (feverFx.phase === 'enter') {
          const t = clamp((nowSec - feverFx.phaseStart) / feverFx.enterDuration, 0, 1);
          const intensity = clamp(0.56 + easeOutCubic(t) * 0.68 + feverFx.hitPulse * 0.22, 0, 1.35);
          return { phase:'enter', intensity, enterT:t, exitT:0 };
        }
        if (feverFx.phase === 'active') {
          const intensity = clamp(1 + feverFx.hitPulse * 0.24, 0, 1.35);
          return { phase:'active', intensity, enterT:1, exitT:0 };
        }
        const t = clamp((nowSec - feverFx.phaseStart) / feverFx.exitDuration, 0, 1);
        const intensity = clamp((1 - easeInCubic(t)) + feverFx.hitPulse * 0.18, 0, 1.1);
        return { phase:'exit', intensity, enterT:1, exitT:t };
      }

      function updateFeverEffects(dt) {
        const targetQuality = dt > 0.029 ? 0.68 : dt > 0.024 ? 0.84 : 1.0;
        runtimeFxQuality += (targetQuality - runtimeFxQuality) * Math.min(1, dt * 4.2);
        runtimeFxQuality = clamp(runtimeFxQuality, 0.58, 1.0);

        scorePulse = Math.max(0, scorePulse - dt * (reducedMotionQuery.matches ? 4.1 : 6.4));
        feverFx.hitPulse = Math.max(0, feverFx.hitPulse - dt * (reducedMotionQuery.matches ? 2.8 : 4.6));
        feverFx.flash = Math.max(0, feverFx.flash - dt * (reducedMotionQuery.matches ? 1.8 : 2.8));

        const state = getFeverVisualState(totalElapsed);
        if (feverFx.phase === 'enter' && state.enterT >= 1) {
          setFeverPhase('active', totalElapsed);
        } else if (feverFx.phase === 'exit' && state.exitT >= 1) {
          setFeverPhase('idle', totalElapsed);
        }

        for (let i=feverShockwaves.length-1; i>=0; i--) {
          const w = feverShockwaves[i];
          w.t += dt;
          if (w.t > w.life) feverShockwaves.splice(i, 1);
        }

        for (let i=feverSparks.length-1; i>=0; i--) {
          const s = feverSparks[i];
          s.t += dt;
          if (s.t > s.life) { feverSparks.splice(i, 1); continue; }
          if (s.mode !== 'converge') s.vy += 320 * dt;
          s.x += s.vx * dt;
          s.y += s.vy * dt;
        }

        for (let i=feverHitBursts.length-1; i>=0; i--) {
          feverHitBursts[i].t += dt;
          if (feverHitBursts[i].t > feverHitBursts[i].life) feverHitBursts.splice(i, 1);
        }

        updateScorePulseStyles();
      }

      function detectDeviceType() {
        const touchPoints = navigator.maxTouchPoints || 0;
        const coarsePointer = coarsePointerQuery.matches;
        const width = window.innerWidth;
        const dpr = window.devicePixelRatio || 1;
        const touchCapable = touchPoints > 0 || coarsePointer;

        if ((touchCapable && width <= 760) || width <= 430) return 'mobile';
        if ((touchCapable && width <= 1180) || (width <= 1024 && dpr >= 1.25)) return 'tablet';
        return 'desktop';
      }

      function applyResponsiveProfile() {
        const width = window.innerWidth;
        const dpr = window.devicePixelRatio || 1;
        const coarsePointer = coarsePointerQuery.matches;
        const reducedMotion = reducedMotionQuery.matches;
        const prevCanvasW = canvas.width;
        const prevCanvasH = canvas.height;
        const canvasRect = canvas.getBoundingClientRect();
        const nextCanvasW = Math.max(320, Math.round(canvasRect.width || canvas.clientWidth || prevCanvasW));
        const nextCanvasH = Math.max(180, Math.round(canvasRect.height || canvas.clientHeight || prevCanvasH));
        const deviceType = detectDeviceType();
        const preset = DEVICE_PRESETS[deviceType];
        const targetCanvasW = deviceType === 'desktop' ? BASE_CANVAS_W : nextCanvasW;
        const targetCanvasH = deviceType === 'desktop' ? BASE_CANVAS_H : nextCanvasH;

        if (targetCanvasW !== prevCanvasW || targetCanvasH !== prevCanvasH) {
          const scaleX = targetCanvasW / prevCanvasW;
          const scaleY = targetCanvasH / prevCanvasH;
          canvas.width = targetCanvasW;
          canvas.height = targetCanvasH;

          if (Number.isFinite(scaleX) && Number.isFinite(scaleY) && scaleX > 0 && scaleY > 0) {
            basket.x *= scaleX;
            if (basket.targetX != null) basket.targetX *= scaleX;
            for (const o of objects) {
              o.x *= scaleX;
              o.y *= scaleY;
              o.r *= Math.min(scaleX, scaleY);
            }
            for (const p of pops) {
              p.x *= scaleX;
              p.y *= scaleY;
            }
            for (const ft of floatTexts) {
              ft.x *= scaleX;
              ft.y *= scaleY;
            }
            for (const w of feverShockwaves) {
              w.x *= scaleX;
              w.y *= scaleY;
              w.startR *= Math.min(scaleX, scaleY);
              w.endR *= Math.min(scaleX, scaleY);
              w.width *= Math.min(scaleX, scaleY);
            }
            for (const s of feverSparks) {
              s.x *= scaleX;
              s.y *= scaleY;
            }
            for (const hb of feverHitBursts) {
              hb.x *= scaleX;
              hb.y *= scaleY;
              hb.r0 *= Math.min(scaleX, scaleY);
              hb.r1 *= Math.min(scaleX, scaleY);
            }
            feverFx.originX *= scaleX;
            feverFx.originY *= scaleY;
          }
        }

        const dprFxPenalty = dpr >= 3 ? 0.90 : dpr >= 2 ? 0.95 : 1.0;
        const reducedFxMul = reducedMotion
          ? (deviceType === 'mobile' ? 0.50 : deviceType === 'tablet' ? 0.58 : 0.64)
          : 1.0;
        const motionScale = reducedMotion ? (deviceType === 'mobile' ? 0.45 : 0.55) : 1.0;
        const hudScale = clamp(preset.hudScale * (coarsePointer ? 1.02 : 1.0), 0.78, 1.08);
        const uiScale = clamp(preset.uiScale * (coarsePointer ? 1.01 : 1.0), 0.80, 1.10);
        const fx = clamp(preset.fxDensity * dprFxPenalty * reducedFxMul, 0.18, 1.00);
        const pauseScale = clamp(preset.pauseScale * motionScale, 0.62, 1.02);
        const tapTargetPx = Math.max(preset.tapTarget, coarsePointer ? 44 : preset.tapTarget);
        const hudTop = width <= 680 ? 20 : 14;
        const hudSide = width <= 680 ? 10 : 14;

        root.dataset.device = deviceType;
        root.dataset.motion = reducedMotion ? 'reduced' : 'full';

        root.style.setProperty('--ui-scale', uiScale.toFixed(3));
        root.style.setProperty('--hud-scale', hudScale.toFixed(3));
        root.style.setProperty('--title-scale', preset.titleScale.toFixed(3));
        root.style.setProperty('--fx-density', fx.toFixed(3));
        root.style.setProperty('--fruit-scale', preset.fruitScale.toFixed(3));
        root.style.setProperty('--basket-scale', preset.basketScale.toFixed(3));
        root.style.setProperty('--pause-scale', pauseScale.toFixed(3));
        root.style.setProperty('--motion-scale', motionScale.toFixed(3));
        root.style.setProperty('--tap-target', `${tapTargetPx}px`);
        root.style.setProperty('--hud-inset-top', `${hudTop}px`);
        root.style.setProperty('--hud-inset-side', `${hudSide}px`);

        fxDensity = fx;
        particleDensity = clamp(fx * (reducedMotion ? 0.65 : 0.92), 0.14, 1.06);
        backgroundMotionScale = clamp(motionScale * (reducedMotion ? 0.88 : 1.00), 0.32, 1.00);
        rotationMotionScale = clamp(motionScale * (reducedMotion ? 0.78 : 1.00), 0.28, 1.00);
        pausePanelScale = pauseScale;
        floatTextScale = clamp(uiScale, 0.82, 1.05);
        rebuildFeverStreams();

        const prevMinX = basket.w / 2 + 14;
        const prevMaxX = canvas.width - basket.w / 2 - 14;
        const prevSpan = Math.max(1, prevMaxX - prevMinX);
        const normalizedX = clamp((basket.x - prevMinX) / prevSpan, 0, 1);

        basket.w = BASE_BASKET_W * preset.basketScale;
        basket.h = BASE_BASKET_H * preset.basketScale;
        basket.y = canvas.height - Math.max(76, canvas.height * 0.125);

        const minX = basket.w / 2 + 14;
        const maxX = canvas.width - basket.w / 2 - 14;
        basket.x = minX + normalizedX * Math.max(1, maxX - minX);
        basket.targetX = basket.targetX == null ? null : clamp(basket.targetX, minX, maxX);

        fruitRadiusMin = BASE_FRUIT_RADIUS_MIN * preset.fruitScale;
        fruitRadiusMax = BASE_FRUIT_RADIUS_MAX * preset.fruitScale;
      }

      let responsiveRaf = null;
      function scheduleResponsiveProfileApply() {
        if (responsiveRaf != null) return;
        responsiveRaf = requestAnimationFrame(() => {
          responsiveRaf = null;
          applyResponsiveProfile();
        });
      }

      function updateDrawFixScale() {
        const rect = canvas.getBoundingClientRect();
        if (!rect.width || !rect.height || !canvas.width || !canvas.height) {
          drawFixScaleY = 1;
          return;
        }
        const sx = rect.width / canvas.width;
        const sy = rect.height / canvas.height;
        if (!sx || !sy) {
          drawFixScaleY = 1;
          return;
        }
        drawFixScaleY = clamp(sx / sy, 0.55, 1.65);
      }

      function updateHearts() {
        heartsEl.innerHTML = '';
        for (let i=0;i<MAX_MISSES;i++){
          const heart = document.createElement('span');
          const alive = i < (MAX_MISSES - misses);
          heart.setAttribute('class', `life-heart ${alive ? 'on' : 'off'}`);
          heart.textContent = '♥';
          heart.setAttribute('aria-hidden', 'true');
          heartsEl.appendChild(heart);
        }
        heartsEl.setAttribute('aria-label', `ライフ ${Math.max(0, MAX_MISSES - misses)} / ${MAX_MISSES}`);
      }

      function resetOverlayTextToStart() {
        overlay.querySelector('.title').textContent = '🍓 フルーツキャッチ';
        overlay.querySelector('.subtitle').textContent = 'カゴを動かして、フルーツをキャッチしよう！';
        overlay.querySelector('.how').innerHTML =
          `← / → か A / D で移動<br/>
           マウスやタッチでも移動OK<br/>
           3回ミスでゲームオーバー<br/>
           ⭐を取るとフィーバー（得点2倍）`;
        startBtn.textContent = 'スタート！';
      }

      function resetState() {
        score = 0;
        misses = 0;
        objects.length = 0;
        pops.length = 0;
        floatTexts.length = 0;
        totalElapsed = 0;
        fever = false;
        feverEnd = 0;
        gameOver = false;
        paused = false;

        basket.x = canvas.width/2;
        basket.y = canvas.height - Math.max(76, canvas.height * 0.125);
        basket.targetX = null;

        scoreEl.textContent = '0';
        feverTimeEl.textContent = `${FEVER_DURATION.toFixed(1)}s`;
        speedMulEl.textContent = 'x1.00';
        updateHearts();

        pauseBtn.textContent = '一時停止';
        clearFeverVisualState();
        feverBadge.classList.remove('show');

        if (music && soundOn) {
          music.setEnabled(true);
          music.setMode('normal');
        }
      }

      function startGame() {
        overlay.classList.remove('show');
        resetState();
        running = true;

        if (audioCtx) audioCtx.resume?.();
        setMusicEnabled(soundOn);
      }

      function restartGame() {
        overlay.classList.remove('show');
        resetState();
        running = true;

        if (audioCtx) audioCtx.resume?.();
        setMusicEnabled(soundOn);
      }

      function togglePause() {
        if (!running || gameOver) return;
        paused = !paused;
        pauseBtn.textContent = paused ? '再開' : '一時停止';

        if (music) {
          if (paused) music.setEnabled(false);
          else setMusicEnabled(soundOn);
        }
      }

      function endGame() {
        gameOver = true;
        running = false;
        fever = false;
        clearFeverVisualState();
        feverBadge.classList.remove('show');

        if (music) music.setEnabled(false);

        overlay.querySelector('.title').textContent = 'ゲームオーバー';
        overlay.querySelector('.subtitle').textContent = `スコア: ${score}`;
        overlay.querySelector('.how').innerHTML = `おつかれさま！<br/>もう一度遊ぶ？`;
        startBtn.textContent = 'もう一回';
        overlay.classList.add('show');
      }

      // Particles & float text
      function pop(x, y, color, n=14) {
        const count = Math.max(2, Math.round(n * particleDensity));
        const velocityScale = 0.70 + particleDensity * 0.50;
        const radiusScale = 0.75 + particleDensity * 0.35;
        for (let i=0;i<count;i++){
          pops.push({
            x, y,
            vx: (Math.random()*2-1) * 420 * velocityScale,
            vy: ((Math.random()*2-1) * 420 - 120) * velocityScale,
            r: (Math.random()*6 + 3) * radiusScale,
            life: 0.5 + Math.random()*0.22,
            t: 0,
            color
          });
        }
      }

      function addFloatText(x, y, text, color) {
        floatTexts.push({
          x, y,
          vy: -90,
          t: 0,
          life: 0.85,
          text,
          color
        });
      }

      // Collision (generous)
      function intersectsCircleRect(cx, cy, r, rx, ry, rw, rh) {
        const x = clamp(cx, rx, rx + rw);
        const y = clamp(cy, ry, ry + rh);
        const dx = cx - x;
        const dy = cy - y;
        return (dx*dx + dy*dy) <= r*r;
      }

      function intersectsObjBasket(o) {
        const bx = basket.x - basket.w/2;
        const by = basket.y - basket.h/2;
        const bw = basket.w;
        const bh = basket.h;
        const padX = 18;
        const padY = 10;
        return intersectsCircleRect(o.x, o.y, o.r, bx - padX, by - padY, bw + padX*2, bh + padY*2);
      }

      // Spawning
      let spawnTimer = 0;

      function globalSpeedMultiplier() {
        // every 30 sec +10%
        const steps = Math.floor(totalElapsed / 30);
        return Math.pow(1.10, steps);
      }

      function spawnObject() {
        const r = rand(fruitRadiusMin, fruitRadiusMax);
        const x = rand(r+18, canvas.width - r - 18);

        const isStar = Math.random() < STAR.chance;

        if (isStar) {
          objects.push({
            kind: 'star',
            emoji: STAR.emoji,
            x, y: -r - 10,
            r: r * 0.92,
            baseMul: 1.00,
            points: 0,
            color: '#ffd670',
            rot: rand(0, Math.PI*2),
            spin: rand(-2.8, 2.8),
            vyBase: baseFallSpeed() * 1.05
          });
          return;
        }

        const t = FRUITS[Math.floor(Math.random()*FRUITS.length)];
        objects.push({
          kind: 'fruit',
          emoji: t.emoji,
          x, y: -r - 10,
          r,
          baseMul: t.mul,
          points: t.points,
          color: t.color,
          rot: rand(0, Math.PI*2),
          spin: rand(-2.2, 2.2),
          vyBase: baseFallSpeed()
        });
      }

      // Drawing helpers
      function roundedRect(x,y,w,h,r){
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr,y);
        ctx.arcTo(x+w,y,x+w,y+h,rr);
        ctx.arcTo(x+w,y+h,x,y+h,rr);
        ctx.arcTo(x,y+h,x,y,rr);
        ctx.arcTo(x,y,x+w,y,rr);
        ctx.closePath();
      }

      function drawFeverBackdrop(now, feverState, dynamicFx) {
        if (feverState.intensity <= 0.001) return;
        const intensity = feverState.intensity;
        const pulseFreq = reducedMotionQuery.matches ? 0.0045 : 0.0078;
        const pulse = 0.5 + 0.5 * Math.sin(now * pulseFreq * backgroundMotionScale + feverFx.hitPulse * 2.2);
        const centerX = feverFx.phase === 'enter' ? feverFx.originX : canvas.width * 0.5;
        const centerY = feverFx.phase === 'enter' ? feverFx.originY : canvas.height * 0.34;
        const auraScale = feverState.phase === 'exit' ? (1.08 - feverState.exitT * 0.24) : (1.0 + pulse * 0.18);

        ctx.save();
        const g = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        g.addColorStop(0, 'rgba(255,214,112,.76)');
        g.addColorStop(0.42, 'rgba(255,112,166,.72)');
        g.addColorStop(1, 'rgba(155,93,229,.70)');
        ctx.globalAlpha = (0.20 + pulse * 0.24) * intensity;
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();

        ctx.save();
        const aura = ctx.createRadialGradient(
          centerX,
          centerY,
          Math.max(24, canvas.width * 0.03),
          centerX,
          centerY,
          canvas.width * 0.64 * auraScale
        );
        aura.addColorStop(0, 'rgba(255,255,255,0.75)');
        aura.addColorStop(0.24, 'rgba(255,214,112,0.52)');
        aura.addColorStop(0.58, 'rgba(255,112,166,0.30)');
        aura.addColorStop(1, 'rgba(155,93,229,0)');
        ctx.globalAlpha = (0.26 + pulse * 0.20) * intensity;
        ctx.fillStyle = aura;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();

        const streamAlpha = Math.min(0.52, (0.12 + intensity * 0.22) * (0.5 + dynamicFx * 0.5));
        if (streamAlpha > 0.01 && feverStreams.length) {
          ctx.save();
          ctx.globalCompositeOperation = 'lighter';
          for (let i=0; i<feverStreams.length; i++) {
            const s = feverStreams[i];
            const travel = ((now * 0.001 * (100 + s.speed * 95) * backgroundMotionScale) + s.seed * 0.73) % (canvas.width + s.len * 2);
            const x = travel - s.len;
            const y = canvas.height * s.lane + Math.sin(now * 0.0018 * s.speed + s.seed) * s.amp * (0.22 + intensity * 0.78);
            ctx.globalAlpha = streamAlpha * (0.65 + (s.tone % 3) * 0.18);
            ctx.strokeStyle = s.tone === 0 ? '#ffd670' : s.tone === 1 ? '#ff70a6' : '#ffffff';
            ctx.lineWidth = s.width * (0.72 + intensity * 0.42);
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + s.len, y - s.amp * 0.24);
            ctx.stroke();
          }
          ctx.restore();
        }

        if (feverFx.flash > 0.001) {
          ctx.save();
          ctx.globalAlpha = feverFx.flash * (reducedMotionQuery.matches ? 0.24 : 0.38);
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.restore();
        }
      }

      function drawFeverShockwavesLayer() {
        if (!feverShockwaves.length) return;
        const density = getRuntimeFxDensity();
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (const w of feverShockwaves) {
          if (w.t < 0) continue;
          const p = clamp(w.t / w.life, 0, 1);
          const k = w.mode === 'collapse' ? easeInCubic(p) : easeOutCubic(p);
          const radius = w.startR + (w.endR - w.startR) * k;
          const alpha = (1 - p) * (w.mode === 'collapse' ? 0.58 : 0.72) * (0.45 + density * 0.55);
          if (alpha <= 0.01) continue;
          ctx.globalAlpha = alpha;
          ctx.strokeStyle = `rgba(${w.color}, 1)`;
          ctx.lineWidth = Math.max(1.6, w.width * (1 - p * 0.78));
          ctx.beginPath();
          ctx.arc(w.x, w.y, radius, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawFeverSparkLayer() {
        if (!feverSparks.length) return;
        const toneColor = ['#ffd670', '#ff70a6', '#ffffff'];
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (const s of feverSparks) {
          const lifeK = 1 - (s.t / s.life);
          if (lifeK <= 0) continue;
          const trail = s.mode === 'converge' ? 0.022 : 0.032;
          const px = s.x - s.vx * trail;
          const py = s.y - s.vy * trail;
          ctx.globalAlpha = lifeK * (s.mode === 'hit' ? 0.95 : 0.82);
          ctx.strokeStyle = toneColor[s.tone % toneColor.length];
          ctx.lineWidth = Math.max(1.2, s.size * lifeK);
          ctx.beginPath();
          ctx.moveTo(px, py);
          ctx.lineTo(s.x, s.y);
          ctx.stroke();
          if (s.mode === 'hit') {
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.size * lifeK * 0.8, 0, Math.PI * 2);
            ctx.fillStyle = toneColor[s.tone % toneColor.length];
            ctx.fill();
          }
        }
        ctx.restore();
      }

      function drawFeverHitBurstsLayer() {
        if (!feverHitBursts.length) return;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (const hb of feverHitBursts) {
          const p = clamp(hb.t / hb.life, 0, 1);
          const lifeK = 1 - p;
          if (lifeK <= 0) continue;
          const ringR = hb.r0 + (hb.r1 - hb.r0) * easeOutCubic(p);
          ctx.globalAlpha = lifeK * 0.78;
          ctx.strokeStyle = hb.color;
          ctx.lineWidth = Math.max(1.6, 8 * lifeK);
          ctx.beginPath();
          ctx.arc(hb.x, hb.y, ringR, 0, Math.PI * 2);
          ctx.stroke();

          const cross = 8 + ringR * 0.28;
          ctx.lineWidth = Math.max(1.2, 5 * lifeK);
          ctx.beginPath();
          ctx.moveTo(hb.x - cross, hb.y);
          ctx.lineTo(hb.x + cross, hb.y);
          ctx.moveTo(hb.x, hb.y - cross);
          ctx.lineTo(hb.x, hb.y + cross);
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawBackground() {
        const now = performance.now();
        const dynamicFx = clamp(fxDensity * runtimeFxQuality, 0.18, 1.18);
        const feverState = getFeverVisualState(totalElapsed);
        const feverIntensity = feverState.intensity;
        const feverBoost = 1 + feverIntensity * (reducedMotionQuery.matches ? 0.28 : 0.55);
        const t = now * 0.0002 * backgroundMotionScale * feverBoost;
        const hillStep = Math.max(40, Math.round(56 / Math.max(0.35, dynamicFx)));
        const confettiCount = Math.max(6, Math.round((20 + feverIntensity * 22) * dynamicFx));

        drawFeverBackdrop(now, feverState, dynamicFx);

        // Soft hills
        ctx.save();
        ctx.globalAlpha = 0.25 + feverIntensity * 0.08;
        ctx.fillStyle = feverIntensity > 0.08 ? '#fff8ff' : '#ffffff';
        ctx.beginPath();
        ctx.moveTo(0, canvas.height);
        for (let x=0; x<=canvas.width; x+=hillStep){
          const y = canvas.height - 80 - Math.sin(x*0.008 + t*3) * (16 + feverIntensity * 12);
          ctx.lineTo(x, y);
        }
        ctx.lineTo(canvas.width, canvas.height);
        ctx.closePath();
        ctx.fill();

        ctx.globalAlpha = 0.18 + feverIntensity * 0.08;
        ctx.beginPath();
        ctx.moveTo(0, canvas.height);
        for (let x=0; x<=canvas.width; x+=hillStep){
          const y = canvas.height - 35 - Math.sin(x*0.01 + t*2) * (11 + feverIntensity * 8);
          ctx.lineTo(x, y);
        }
        ctx.lineTo(canvas.width, canvas.height);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // Confetti dots
        ctx.save();
        ctx.globalAlpha = (0.21 + feverIntensity * 0.2) * (0.45 + dynamicFx * 0.55);
        for (let i=0;i<confettiCount;i++){
          const speed = (0.05 + feverIntensity * 0.05) * backgroundMotionScale;
          const x = (i * 97 + (now * speed)) % canvas.width;
          const y = 90 + (i * 53) % Math.max(220, Math.round(320 * (0.65 + dynamicFx * 0.35)));
          ctx.beginPath();
          ctx.arc(x, y, (3 + (i % 4)) * (0.75 + dynamicFx * 0.3), 0, Math.PI*2);
          ctx.fillStyle = ['#ff70a6','#ffd670','#46d19f','#9b5de5','#ff9770','#ffffff'][i % 6];
          ctx.fill();
        }
        ctx.restore();

        drawFeverShockwavesLayer();
      }

      function drawBasket() {
        const x = basket.x;
        const y = basket.y;
        const w = basket.w;
        const h = basket.h;

        ctx.save();
        ctx.translate(x, y);
        ctx.scale(1, drawFixScaleY);

        // Body
        ctx.fillStyle = '#ffffff';
        roundedRect(-w/2, -h/2, w, h, 18);
        ctx.fill();

        // Inside
        ctx.fillStyle = '#f1f5f9';
        roundedRect(-w/2+10, -h/2+10, w-20, h-20, 14);
        ctx.fill();

        // Candy stripes
        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        roundedRect(-w/2+10, -h/2+10, w-20, h-20, 14);
        ctx.clip();
        for (let i=-w; i<w; i+=26){
          ctx.fillStyle = (i/26)%2===0 ? '#ff70a6' : '#ffd670';
          ctx.beginPath();
          ctx.moveTo(i, -h);
          ctx.lineTo(i+12, -h);
          ctx.lineTo(i+w, h);
          ctx.lineTo(i+w-12, h);
          ctx.closePath();
          ctx.globalAlpha = 0.18;
          ctx.fill();
        }
        ctx.restore();

        // Handle
        ctx.strokeStyle = '#1f2937';
        ctx.lineWidth = 7;
        ctx.globalAlpha = 0.55;
        ctx.beginPath();
        ctx.arc(0, -h/2+4, w*0.28, Math.PI, 0);
        ctx.stroke();

        ctx.restore();
      }

      function drawObject(o) {
        ctx.save();
        ctx.translate(o.x, o.y);
        ctx.scale(1, drawFixScaleY);
        ctx.rotate(o.rot);

        // glow for star
        if (o.kind === 'star') {
          ctx.globalAlpha = 0.28;
          ctx.beginPath();
          ctx.arc(0, 0, o.r*1.35, 0, Math.PI*2);
          ctx.fillStyle = '#ffd670';
          ctx.fill();
        }

        ctx.globalAlpha = 1;
        ctx.font = `${Math.floor(o.r*1.65)}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(o.emoji, 0, 0);

        ctx.restore();
      }

      function drawParticles(dt) {
        for (let i=pops.length-1;i>=0;i--){
          const p = pops[i];
          p.t += dt;
          const k = 1 - (p.t / p.life);
          if (k <= 0) { pops.splice(i,1); continue; }
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vy += 980 * dt;

          const alpha = Math.max(0, k) * particleDensity;
          if (alpha <= 0.01) continue;
          ctx.globalAlpha = alpha * (fever ? 1.0 : 0.9);
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r * (0.52 + k * (0.48 + particleDensity * 0.25)), 0, Math.PI*2);
          ctx.fillStyle = p.color;
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }

      function drawFloatTexts(dt) {
        for (let i=floatTexts.length-1;i>=0;i--){
          const ft = floatTexts[i];
          ft.t += dt;
          const k = 1 - (ft.t / ft.life);
          if (k <= 0) { floatTexts.splice(i,1); continue; }
          ft.y += ft.vy * dt;

          ctx.save();
          ctx.globalAlpha = Math.max(0, k);
          ctx.translate(ft.x, ft.y);
          ctx.scale(1, drawFixScaleY);
          const fontSize = Math.max(20, Math.round(28 * floatTextScale));
          ctx.font = `900 ${fontSize}px "M PLUS Rounded 1c","Zen Maru Gothic",system-ui,sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = '#ffffff';
          ctx.strokeStyle = 'rgba(31,41,55,.35)';
          ctx.lineWidth = Math.max(4, fontSize * 0.21);
          ctx.strokeText(ft.text, 0, 0);
          ctx.fillStyle = ft.color;
          ctx.fillText(ft.text, 0, 0);
          ctx.restore();
        }
      }

      // Main loop
      let last = performance.now();
      function frame(now) {
        const dt = Math.min(0.033, (now - last) / 1000);
        last = now;

        // Clear
        ctx.clearRect(0,0,canvas.width,canvas.height);
        updateDrawFixScale();

        // Background
        drawBackground();

        if (running && !paused) {
          totalElapsed += dt;
          updateFeverEffects(dt);

          // speed multiplier (every 30 sec +10%)
          const gMul = globalSpeedMultiplier();
          speedMulEl.textContent = `x${gMul.toFixed(2)}`;

          // Basket movement
          const left = keys.has('ArrowLeft') || keys.has('a') || keys.has('A');
          const right = keys.has('ArrowRight') || keys.has('d') || keys.has('D');

          if (left) basket.vx = -basket.speed;
          else if (right) basket.vx = basket.speed;
          else basket.vx *= 0.85;

          // Mouse target easing
          if (basket.targetX != null) {
            const dx = basket.targetX - basket.x;
            basket.x += dx * (1 - Math.pow(0.000001, dt));
          } else {
            basket.x += basket.vx * dt;
          }

          basket.x = clamp(basket.x, basket.w/2 + 14, canvas.width - basket.w/2 - 14);

          // Spawn
          spawnTimer += dt;
          if (spawnTimer >= spawnInterval()) {
            spawnTimer = 0;
            spawnObject();
          }

          // Fever timer UI & end
          if (fever) {
            const remain = Math.max(0, feverEnd - totalElapsed);
            feverTimeEl.textContent = `${remain.toFixed(1)}s`;
            if (remain <= 0) {
              fever = false;
              if (music && soundOn) music.setMode('normal');
              setFeverPhase('exit', totalElapsed);
              pop(canvas.width*0.5, canvas.height*0.22, '#ffffff', 24);
            }
          }

          // Update objects
          for (let i=objects.length-1;i>=0;i--){
            const o = objects[i];

            const vy = o.vyBase * o.baseMul * gMul;

            o.y += vy * dt;
            o.rot += o.spin * dt * rotationMotionScale;

            // Catch?
            if (intersectsObjBasket(o)) {
              objects.splice(i,1);

              if (o.kind === 'star') {
                // Fever start (20s), points x2
                fever = true;
                feverEnd = totalElapsed + FEVER_DURATION;
                setFeverPhase('enter', totalElapsed, o.x, o.y);

                pop(o.x, o.y, '#ffd670', 34);
                pop(o.x, o.y, '#ff70a6', 28);
                pop(o.x, o.y, '#9b5de5', 20);
                addFloatText(o.x, o.y - 10, 'フィーバー！', '#ffd670');
                triggerFeverHitFeedback(o.x, o.y, '#ffd670');

                sfx('star');
                if (music && soundOn) music.setMode('fever');
                continue;
              }

              const basePts = o.points;
              const got = fever ? basePts * 2 : basePts;

              score += got;
              scoreEl.textContent = String(score);

              pop(o.x, o.y, o.color, fever ? 30 : 14);
              addFloatText(o.x, o.y - 12, `+${got}`, fever ? '#ffd670' : o.color);
              if (fever) triggerFeverHitFeedback(o.x, o.y, '#ffd670');
              sfx('catch');
              continue;
            }

            // Missed?
            if (o.y - o.r > canvas.height + 10) {
              objects.splice(i,1);

              if (o.kind === 'star') continue;

              misses++;
              updateHearts();
              pop(clamp(o.x, 40, canvas.width-40), canvas.height-55, '#ff4d6d', 14);
              sfx('miss');

              if (misses >= MAX_MISSES) {
                endGame();
                break;
              }
            }
          }
        }

        // Draw objects
        for (const o of objects) drawObject(o);

        // Draw basket
        drawBasket();

        // Fever foreground FX
        drawFeverSparkLayer();
        drawFeverHitBurstsLayer();

        // Particles & float texts
        drawParticles(dt);
        drawFloatTexts(dt);

        // Pause label
        if (running && paused && !gameOver) {
          ctx.save();
          ctx.translate(canvas.width/2, canvas.height/2);
          ctx.scale(1, drawFixScaleY);
          ctx.globalAlpha = 0.92;
          ctx.fillStyle = '#ffffff';
          const panelW = Math.min(canvas.width * 0.76, 380 * pausePanelScale);
          const panelH = Math.min(canvas.height * 0.34, 156 * pausePanelScale);
          const corner = Math.max(18, 26 * pausePanelScale);
          roundedRect(-panelW/2, -panelH/2, panelW, panelH, corner);
          ctx.fill();
          ctx.fillStyle = '#1f2937';
          const pauseFontSize = Math.max(30, Math.round(44 * pausePanelScale));
          ctx.font = `900 ${pauseFontSize}px "M PLUS Rounded 1c","Zen Maru Gothic",system-ui,sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('一時停止', 0, 1);
          ctx.restore();
        }

        requestAnimationFrame(frame);
      }

      // Init
      applyResponsiveProfile();
      window.addEventListener('resize', scheduleResponsiveProfileApply, {passive:true});
      window.addEventListener('orientationchange', scheduleResponsiveProfileApply, {passive:true});
      if (typeof reducedMotionQuery.addEventListener === 'function') {
        reducedMotionQuery.addEventListener('change', scheduleResponsiveProfileApply);
      } else if (typeof reducedMotionQuery.addListener === 'function') {
        reducedMotionQuery.addListener(scheduleResponsiveProfileApply);
      }
      if (typeof coarsePointerQuery.addEventListener === 'function') {
        coarsePointerQuery.addEventListener('change', scheduleResponsiveProfileApply);
      } else if (typeof coarsePointerQuery.addListener === 'function') {
        coarsePointerQuery.addListener(scheduleResponsiveProfileApply);
      }
      updateHearts();
      resetOverlayTextToStart();
      requestAnimationFrame(frame);

      // Start with overlay (music off until start)
      if (music) music.setEnabled(false);
    })();
  </script>
</body>
</html>
